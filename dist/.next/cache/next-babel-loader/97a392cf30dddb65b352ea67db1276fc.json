{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport moment from 'moment';\nimport { message } from 'antd';\nimport { getResponseError } from 'src/lib';\nimport { APIRequest } from './api-request';\n\nvar StreamService = /*#__PURE__*/function (_APIRequest) {\n  _inherits(StreamService, _APIRequest);\n\n  var _super = _createSuper(StreamService);\n\n  function StreamService() {\n    _classCallCheck(this, StreamService);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(StreamService, [{\n    key: \"getSessionId\",\n    value: function getSessionId(id, type) {\n      return this.get(\"/streaming/session/\".concat(id, \"/\").concat(type));\n    }\n  }, {\n    key: \"goLive\",\n    value: function goLive() {\n      return this.post('/streaming/live');\n    }\n  }, {\n    key: \"joinPublicChat\",\n    value: function joinPublicChat(performerId) {\n      return this.post(\"/streaming/join/\".concat(performerId));\n    }\n  }, {\n    key: \"requestPrivateChat\",\n    value: function requestPrivateChat(performerId) {\n      return this.post(\"/streaming/private-chat/\".concat(performerId));\n    }\n  }, {\n    key: \"acceptPrivateChat\",\n    value: function acceptPrivateChat(id) {\n      return this.get(\"/streaming/private-chat/\".concat(id));\n    }\n  }, {\n    key: \"startGroupChat\",\n    value: function startGroupChat() {\n      return this.post('/streaming/group-chat');\n    }\n  }, {\n    key: \"joinGroupChat\",\n    value: function joinGroupChat(id) {\n      return this.get(\"/streaming/group-chat/\".concat(id));\n    }\n  }, {\n    key: \"generateOneTimeToken\",\n    value: function generateOneTimeToken(data) {\n      return this.post('/streaming/token', data);\n    }\n  }, {\n    key: \"getPublishToken\",\n    value: function () {\n      var _getPublishToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {\n        var expireDate,\n            settings,\n            streamId,\n            secureOption,\n            resp,\n            error,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                expireDate = _args.length > 1 && _args[1] !== undefined ? _args[1] : moment().add(1, 'd').toDate().getTime();\n                _context.prev = 1;\n                settings = options.settings, streamId = options.streamId;\n                secureOption = settings.secureOption;\n\n                if (!secureOption) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 7;\n                return this.generateOneTimeToken({\n                  id: streamId,\n                  type: 'publish',\n                  expireDate: expireDate\n                });\n\n              case 7:\n                resp = _context.sent;\n                return _context.abrupt(\"return\", resp.data.tokenId);\n\n              case 9:\n                return _context.abrupt(\"return\", null);\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](1);\n                _context.next = 16;\n                return Promise.resolve(_context.t0);\n\n              case 16:\n                error = _context.sent;\n                message.error(getResponseError(error));\n                return _context.abrupt(\"return\", null);\n\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 12]]);\n      }));\n\n      function getPublishToken(_x) {\n        return _getPublishToken.apply(this, arguments);\n      }\n\n      return getPublishToken;\n    }()\n  }, {\n    key: \"getSubscriberToken\",\n    value: function () {\n      var _getSubscriberToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {\n        var expireDate,\n            settings,\n            streamId,\n            secureOption,\n            resp,\n            error,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                expireDate = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : moment().add(1, 'd').toDate().getTime();\n                _context2.prev = 1;\n                settings = options.settings, streamId = options.streamId;\n                secureOption = settings.secureOption;\n\n                if (!secureOption) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                _context2.next = 7;\n                return this.generateOneTimeToken({\n                  id: streamId,\n                  type: 'play',\n                  expireDate: expireDate\n                });\n\n              case 7:\n                resp = _context2.sent;\n                return _context2.abrupt(\"return\", resp.data.tokenId);\n\n              case 9:\n                return _context2.abrupt(\"return\", null);\n\n              case 12:\n                _context2.prev = 12;\n                _context2.t0 = _context2[\"catch\"](1);\n                _context2.next = 16;\n                return Promise.resolve(_context2.t0);\n\n              case 16:\n                error = _context2.sent;\n                message.error(getResponseError(error));\n                return _context2.abrupt(\"return\", null);\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 12]]);\n      }));\n\n      function getSubscriberToken(_x2) {\n        return _getSubscriberToken.apply(this, arguments);\n      }\n\n      return getSubscriberToken;\n    }()\n  }, {\n    key: \"getLiveStreamOrVodURL\",\n    value: function () {\n      var _getLiveStreamOrVodURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(options) {\n        var expireDate,\n            _player,\n            appName,\n            settings,\n            streamId,\n            secureOption,\n            viewerURL,\n            extension,\n            oneTimeToken,\n            resp,\n            protocol,\n            error,\n            _args3 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                expireDate = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : moment().add(1, 'd').toDate().getTime();\n                _player = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : 'hls';\n                _context3.prev = 2;\n                // const src = `https://${viewerURL}:5443/${appName}/streams/${streamId}.m3u8${oneTimeToken ? `?token=${oneTimeToken}` : ''}`;\n                // eslint-disable-next-line no-shadow\n                appName = options.appName, settings = options.settings, streamId = options.streamId;\n                secureOption = settings.secureOption, viewerURL = settings.viewerURL;\n                extension = _player === 'hls' ? 'm3u8' : 'mp4';\n\n                if (!(!viewerURL || !appName)) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", '');\n\n              case 8:\n                oneTimeToken = '';\n\n                if (!secureOption) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                _context3.next = 12;\n                return this.generateOneTimeToken({\n                  id: streamId,\n                  type: 'play',\n                  expireDate: expireDate\n                });\n\n              case 12:\n                resp = _context3.sent;\n                oneTimeToken = resp.data.tokenId;\n\n              case 14:\n                protocol = window.location.protocol;\n                return _context3.abrupt(\"return\", \"\".concat(protocol, \"//\").concat(viewerURL, \"/\").concat(appName, \"/streams/\").concat(streamId, \".\").concat(extension).concat(oneTimeToken ? \"?token=\".concat(oneTimeToken) : ''));\n\n              case 18:\n                _context3.prev = 18;\n                _context3.t0 = _context3[\"catch\"](2);\n                _context3.next = 22;\n                return Promise.resolve(_context3.t0);\n\n              case 22:\n                error = _context3.sent;\n                message.error(getResponseError(error));\n                return _context3.abrupt(\"return\", '');\n\n              case 25:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 18]]);\n      }));\n\n      function getLiveStreamOrVodURL(_x3) {\n        return _getLiveStreamOrVodURL.apply(this, arguments);\n      }\n\n      return getLiveStreamOrVodURL;\n    }()\n  }]);\n\n  return StreamService;\n}(APIRequest);\n\nexport var streamService = new StreamService();","map":null,"metadata":{},"sourceType":"module"}