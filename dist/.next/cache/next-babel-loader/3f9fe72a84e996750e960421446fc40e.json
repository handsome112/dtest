{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { message, Checkbox, Table, Tabs, Button } from 'antd';\nimport PageHeader from '@components/common/layout/page-header';\nimport Head from 'next/head';\nimport React, { PureComponent } from 'react';\nimport { performerService } from 'src/services';\nimport { getResponseError } from '@lib/utils';\nimport { connect } from 'react-redux';\nimport './index.less';\n\nclass PerformerGeoBlockPage extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      blockedCountries: [],\n      blockedUsers: [],\n      isLoading: false,\n      isBlocking: false\n    };\n  }\n\n  componentDidMount() {\n    this.search();\n  }\n\n  componentDidUpdate(_, prevState) {\n    const {\n      blockedCountries,\n      isBlocking\n    } = this.state;\n\n    if (isBlocking && blockedCountries !== prevState.blockedCountries) {\n      this.blockCountry(blockedCountries);\n    }\n  }\n\n  handleBlockCountry(code, event) {\n    this.setState({\n      isBlocking: true\n    });\n    const {\n      blockedCountries\n    } = this.state;\n\n    if (event.target && event.target.checked) {\n      // performerService.geoBlock({ countries: blockedCountries });\n      this.setState({\n        blockedCountries: [...blockedCountries, code]\n      });\n    } else {\n      this.setState({\n        blockedCountries: blockedCountries.filter(c => code !== c)\n      });\n    }\n  }\n\n  async handleBlockUser(userId) {\n    if (!window.confirm('Are you sure?')) return;\n    const {\n      blockedUsers\n    } = this.state;\n\n    try {\n      const user = blockedUsers.find(u => u._id === userId);\n      blockedUsers.splice(user, 1);\n      await this.setState(state => {\n        const list = state.blockedUsers.splice(user, 1);\n        return _objectSpread(_objectSpread({}, state), {\n          blockedUsers: list\n        });\n      });\n      performerService.geoBlock({\n        userIds: blockedUsers.length ? blockedUsers.map(b => b._id) : []\n      });\n    } catch (e) {\n      const error = await Promise.resolve(e);\n      message.error(error || 'Something went wrong, please try again later');\n    }\n  }\n\n  async search() {\n    try {\n      this.setState({\n        isLoading: true\n      });\n      const resp = await performerService.getBlockedList();\n      this.setState({\n        blockedCountries: resp.data.countries || [],\n        blockedUsers: resp.data.usersInfo || []\n      });\n    } catch (e) {\n      const error = await Promise.resolve(e);\n      message.error(getResponseError(error || 'An error occurred, please try again!'));\n    } finally {\n      this.setState({\n        isLoading: false\n      });\n    }\n  }\n\n  async blockCountry(blockedCountries) {\n    try {\n      await performerService.geoBlock({\n        countries: blockedCountries\n      });\n    } catch (e) {\n      const error = await Promise.resolve(e);\n      message.error(error || 'Something went wrong, please try again later');\n    } finally {\n      this.setState({\n        isBlocking: false\n      });\n    }\n  }\n\n  render() {\n    const {\n      countries\n    } = this.props;\n    const {\n      isLoading,\n      isBlocking,\n      blockedCountries,\n      blockedUsers\n    } = this.state;\n    const countriesColumns = [{\n      title: 'Country',\n      dataIndex: 'name',\n      key: 'name'\n    }, {\n      title: 'Coutry Code',\n      dataIndex: 'code',\n      key: 'code'\n    }, {\n      title: 'Flag',\n      dataIndex: 'flag',\n      key: 'flag',\n      render: flag => __jsx(\"img\", {\n        src: flag,\n        width: \"50px\",\n        alt: \"\"\n      })\n    }, {\n      title: '#',\n      dataIndex: 'code',\n      key: 'check',\n      render: code => __jsx(Checkbox, {\n        disabled: isBlocking,\n        defaultChecked: !!(blockedCountries.length > 0 && blockedCountries.find(c => c === code)),\n        onChange: this.handleBlockCountry.bind(this, code)\n      })\n    }];\n    const usersColumns = [{\n      title: '# ',\n      dataIndex: '_id',\n      key: 'avatar',\n      render: (avatar, record) => __jsx(\"img\", {\n        src: (record === null || record === void 0 ? void 0 : record.avatar) || '/default-user-icon.png',\n        width: \"50px\",\n        alt: \"\"\n      })\n    }, {\n      title: 'Name ',\n      dataIndex: 'name',\n      key: 'name'\n    }, {\n      title: 'Username',\n      dataIndex: 'username',\n      key: 'username'\n    }, {\n      title: '#',\n      dataIndex: '_id',\n      key: 'check',\n      render: id => __jsx(\"div\", null, __jsx(Button, {\n        onClick: this.handleBlockUser.bind(this, id)\n      }, \"Unblock\"))\n    }];\n    return __jsx(React.Fragment, null, __jsx(Head, null, __jsx(\"title\", null, \"Blocking\")), __jsx(\"div\", {\n      className: \"geo-blocking-page\"\n    }, __jsx(PageHeader, {\n      title: \"Blocking\"\n    }), __jsx(Tabs, {\n      defaultActiveKey: \"geo-block\"\n    }, __jsx(Tabs.TabPane, {\n      tab: \"GEO Blocking\",\n      key: \"geo-block\"\n    }, __jsx(\"div\", null, countries && countries.length > 0 && !isLoading ? __jsx(Table, {\n      pagination: false,\n      dataSource: countries.map((c, index) => _objectSpread(_objectSpread({}, c), {}, {\n        key: `key-country-${index}`\n      })),\n      columns: countriesColumns\n    }) : __jsx(\"p\", {\n      className: \"text-center\"\n    }, \"loading...\"))), __jsx(Tabs.TabPane, {\n      tab: \"Black list users\",\n      key: \"user-block\"\n    }, __jsx(\"div\", null, !isLoading ? __jsx(Table, {\n      pagination: false,\n      dataSource: blockedUsers.map((c, index) => _objectSpread(_objectSpread({}, c), {}, {\n        key: `key-country-${index}`\n      })),\n      columns: usersColumns\n    }) : __jsx(\"p\", {\n      className: \"text-center\"\n    }, \"loading...\"))))));\n  }\n\n}\n\n_defineProperty(PerformerGeoBlockPage, \"authenticate\", true);\n\n_defineProperty(PerformerGeoBlockPage, \"layout\", 'primary');\n\nconst mapStateToProps = state => ({\n  countries: state.settings.countries\n});\n\nexport default connect(mapStateToProps)(PerformerGeoBlockPage);","map":null,"metadata":{},"sourceType":"module"}