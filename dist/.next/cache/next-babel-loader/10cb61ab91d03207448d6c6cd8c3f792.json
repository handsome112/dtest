{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable camelcase */\nimport * as React from 'react';\nimport { streamService } from 'src/services';\nimport classnames from 'classnames';\nimport withAntMedia from 'src/antmedia';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from 'src/antmedia/constants';\n\nclass Subscriber extends React.PureComponent {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"streamIds\", []);\n\n    _defineProperty(this, \"availableStreamIds\", []);\n  }\n\n  async handler(info, obj) {\n    const {\n      webRTCAdaptor,\n      settings\n    } = this.props;\n\n    if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n      if (Array.isArray(this.streamIds)) {\n        const tokens = await Promise.all(this.streamIds.map(streamId => streamService.getSubscriberToken({\n          streamId,\n          settings\n        })));\n        this.streamIds.map((id, i) => webRTCAdaptor.play(id, tokens[i]));\n        return;\n      }\n\n      const token = await streamService.getSubscriberToken({\n        streamId: this.streamIds,\n        settings\n      });\n      webRTCAdaptor.play(this.streamIds, token);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.NEW_STREAM_AVAILABLE) {\n      const availableStream = this.availableStreamIds.find(id => id === obj.streamId);\n\n      if (!availableStream) {\n        this.availableStreamIds.push(obj.streamId);\n        this.createRemoteVideo(obj);\n      }\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_FINISHED) {\n      this.availableStreamIds = this.availableStreamIds.filter(id => id !== obj.streamId);\n      this.removeRemoteVideo(obj.streamId);\n      setTimeout(() => {\n        webRTCAdaptor.getStreamInfo(obj.streamId);\n      }, 3000);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.STREAM_INFORMATION) {\n      if (this.streamIds.includes(obj.streamId)) {\n        const token = await streamService.getSubscriberToken({\n          streamId: obj.streamId,\n          settings\n        });\n        webRTCAdaptor.play(obj.streamId, token);\n      }\n    }\n  }\n\n  async cbErrorHandler(error) {\n    if (error === 'no_stream_exist') {\n      const {\n        webRTCAdaptor,\n        initWebRTCAdaptor\n      } = this.props;\n\n      if (!webRTCAdaptor) {\n        initWebRTCAdaptor(this.handler.bind(this), this.cbErrorHandler.bind(this));\n      } else {\n        this.streamIds.forEach(id => webRTCAdaptor.getStreamInfo(id));\n      }\n    }\n  }\n\n  createRemoteVideo({\n    stream,\n    streamId\n  }) {\n    const {\n      classNames,\n      containerClassName\n    } = this.props;\n    const video = document.createElement('video');\n    const container = document.getElementsByClassName(containerClassName)[0];\n    video.setAttribute('id', `streamId-subscriber-${streamId}`);\n    video.setAttribute('class', classnames(classNames));\n    video.autoplay = true;\n    video.muted = true;\n    video.controls = true;\n    video.playsInline = true;\n    video.width = container.clientWidth / 4;\n    video.height = 100.5;\n    video.srcObject = stream;\n    container.append(video);\n  }\n\n  removeRemoteVideo(streamId) {\n    const {\n      containerClassName\n    } = this.props;\n    const video = document.getElementById(`streamId-subscriber-${streamId}`);\n\n    if (video) {\n      video.srcObject = null;\n      const container = document.getElementsByClassName(containerClassName)[0];\n      container.removeChild(video);\n    }\n  }\n\n  async play(streamIds) {\n    const {\n      initWebRTCAdaptor,\n      initialized,\n      webRTCAdaptor,\n      settings\n    } = this.props;\n    this.streamIds = [...this.streamIds, ...streamIds];\n\n    if (initialized) {\n      if (Array.isArray(streamIds)) {\n        const tokens = await Promise.all(streamIds.map(streamId => streamService.getSubscriberToken({\n          streamId,\n          settings\n        })));\n        streamIds.map((id, i) => webRTCAdaptor.play(id, tokens[i]));\n      }\n\n      return;\n    }\n\n    initWebRTCAdaptor(this.handler.bind(this), this.cbErrorHandler.bind(this));\n  }\n\n  close(streamId) {\n    this.streamIds = this.streamIds.filter(id => id !== streamId);\n  }\n\n  stop() {\n    const {\n      leaveSession\n    } = this.props;\n    this.streamIds = [];\n    this.availableStreamIds = [];\n    leaveSession();\n  }\n\n  render() {\n    return __jsx(React.Fragment, null);\n  }\n\n}\n\nexport default withAntMedia(Subscriber);","map":null,"metadata":{},"sourceType":"module"}