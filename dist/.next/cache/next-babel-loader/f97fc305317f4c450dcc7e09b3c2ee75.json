{"ast":null,"code":"var _jsxFileName = \"/var/www/dtest.live/pages/live/index.tsx\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable camelcase */\nimport React, { PureComponent } from 'react';\nimport Head from 'next/head';\nimport { Row, Col, Button, message } from 'antd';\nimport { connect } from 'react-redux';\nimport { messageService, streamService } from 'src/services';\nimport LivePublisher from '@components/streaming/publisher';\nimport { SocketContext, Event } from 'src/socket';\nimport { getStreamConversationSuccess, loadStreamMessages, resetStreamMessage, resetAllStreamMessage } from '@redux/stream-chat/actions';\nimport { updateStreamingStatus } from '@redux/performer/actions';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from 'src/antmedia/constants';\nimport ChatBox from '@components/stream-chat/chat-box';\nimport UpdateSatusForm from '@components/performer/streaming-status-update-form';\nimport Router from 'next/router';\nimport { getResponseError } from '@lib/utils';\nimport './index.less'; // eslint-disable-next-line no-shadow\n\nvar EVENT_NAME;\n\n(function (EVENT_NAME) {\n  EVENT_NAME[\"ROOM_INFORMATIOM_CHANGED\"] = \"public-room-changed\";\n  EVENT_NAME[\"USER_LEFT_ROOM\"] = \"USER_LEFT_ROOM\";\n})(EVENT_NAME || (EVENT_NAME = {}));\n\nclass PerformerLivePage extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"publisherRef\", void 0);\n\n    _defineProperty(this, \"socket\", void 0);\n\n    _defineProperty(this, \"onbeforeunload\", () => {\n      this.leavePublicRoom();\n    });\n\n    this.state = {\n      loading: false,\n      initialized: false,\n      publish_started: false,\n      total: 0,\n      members: []\n    };\n  }\n\n  componentDidMount() {\n    this.socket = this.context;\n    this.joinPublicRoom();\n    window.addEventListener('beforeunload', this.onbeforeunload);\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      updateSuccess,\n      updateError\n    } = this.props;\n\n    if (prevProps.updateSuccess !== updateSuccess && updateSuccess) {\n      message.success('Update Status Success.');\n    }\n\n    if (prevProps.updateError !== updateError && updateError) {\n      message.error(getResponseError(updateError));\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('beforeunload', this.onbeforeunload);\n    Router.events.off('routeChangeStart', this.onbeforeunload);\n  }\n\n  handler({\n    total,\n    members,\n    conversationId\n  }) {\n    var _activeConversation$d;\n\n    const {\n      activeConversation\n    } = this.props;\n\n    if ((activeConversation === null || activeConversation === void 0 ? void 0 : (_activeConversation$d = activeConversation.data) === null || _activeConversation$d === void 0 ? void 0 : _activeConversation$d._id) === conversationId) {\n      this.setState({\n        total,\n        members\n      });\n    }\n  }\n\n  handleUpdateStatusForm(data) {\n    const {\n      updateStreamingStatus: dispatchUpdateStreamingStatus\n    } = this.props;\n    dispatchUpdateStreamingStatus(data);\n  }\n\n  start() {\n    this.publisherRef && this.publisherRef.start();\n  }\n\n  stop() {\n    window.location.reload();\n  }\n\n  async callback(info) {\n    const {\n      activeConversation\n    } = this.props;\n\n    if (activeConversation && activeConversation.data) {\n      this.socket = this.context;\n\n      if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n        this.setState({\n          initialized: true\n        });\n\n        try {\n          this.setState({\n            loading: true\n          });\n          const resp = await streamService.goLive();\n          this.publisherRef && this.publisherRef.publish(resp.data.sessionId);\n        } catch (e) {\n          const error = await Promise.resolve(e);\n          message.error(getResponseError(error));\n        } finally {\n          this.setState({\n            loading: false\n          });\n        }\n      } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_STARTED) {\n        this.setState({\n          publish_started: true,\n          loading: false\n        });\n        this.socket.emit('public-stream/live', {\n          conversationId: activeConversation.data._id\n        });\n      } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_FINISHED) {\n        this.setState({\n          loading: false,\n          publish_started: false\n        });\n      } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.CLOSED) {\n        this.setState({\n          loading: false,\n          initialized: false,\n          publish_started: false\n        });\n      }\n    }\n  }\n\n  async joinPublicRoom() {\n    const {\n      loadStreamMessages: dispatchLoadStreamMessages,\n      getStreamConversationSuccess: dispatchGetStreamConversationSuccess\n    } = this.props;\n\n    try {\n      this.setState({\n        loading: true\n      });\n      const resp = await streamService.goLive();\n      const {\n        conversation\n      } = resp.data;\n\n      if (conversation && conversation._id) {\n        // this.publisherRef && this.publisherRef.start();\n        dispatchGetStreamConversationSuccess({\n          data: conversation\n        });\n        dispatchLoadStreamMessages({\n          conversationId: conversation._id,\n          limit: 25,\n          offset: 0,\n          type: conversation.type\n        });\n        this.socket = this.context;\n        this.socket && this.socket.emit('public-stream/join', {\n          conversationId: conversation._id\n        });\n      }\n    } catch (e) {\n      const error = await Promise.resolve(e);\n      message.error(getResponseError(error));\n    } finally {\n      this.setState({\n        loading: false\n      });\n    }\n  }\n\n  leavePublicRoom() {\n    const {\n      activeConversation,\n      resetStreamMessage: dispatchResetStreamMessage\n    } = this.props;\n\n    if (this.socket && activeConversation && activeConversation.data) {\n      const conversation = _objectSpread({}, activeConversation.data);\n\n      this.socket.emit('public-stream/leave', {\n        conversationId: conversation._id\n      });\n      dispatchResetStreamMessage();\n    }\n  }\n\n  userLeftRoomHandle({\n    username,\n    conversationId\n  }) {\n    var _activeConversation$d2;\n\n    const {\n      activeConversation\n    } = this.props;\n\n    if ((activeConversation === null || activeConversation === void 0 ? void 0 : (_activeConversation$d2 = activeConversation.data) === null || _activeConversation$d2 === void 0 ? void 0 : _activeConversation$d2._id) === conversationId) {\n      const {\n        total,\n        members\n      } = this.state;\n      this.setState({\n        total: total - 1,\n        members: members.filter(m => m.username !== username)\n      });\n    }\n  }\n\n  async removeAllMessage() {\n    const {\n      activeConversation,\n      performer,\n      resetAllStreamMessage: dispatchResetAllMessage\n    } = this.props;\n\n    if (!activeConversation.data || performer._id !== activeConversation.data.performerId) {\n      return;\n    }\n\n    try {\n      if (!window.confirm('Are you sure you want to remove chat history?')) {\n        return;\n      }\n\n      await messageService.deleteAllMessageInConversation(activeConversation.data._id);\n      dispatchResetAllMessage({\n        conversationId: activeConversation.data._id\n      });\n    } catch (e) {\n      const error = await Promise.resolve(e);\n      message.error(getResponseError(error));\n    }\n  }\n\n  render() {\n    const {\n      performer,\n      activeConversation,\n      updating\n    } = this.props;\n    const {\n      loading,\n      initialized,\n      publish_started,\n      members,\n      total\n    } = this.state;\n    return __jsx(React.Fragment, null, __jsx(Head, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 243,\n        columnNumber: 9\n      }\n    }, __jsx(\"title\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 244,\n        columnNumber: 11\n      }\n    }, \"Go Live\")), __jsx(Event, {\n      event: EVENT_NAME.ROOM_INFORMATIOM_CHANGED,\n      handler: this.handler.bind(this),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 247,\n        columnNumber: 9\n      }\n    }), __jsx(Event, {\n      event: EVENT_NAME.USER_LEFT_ROOM,\n      handler: this.userLeftRoomHandle.bind(this),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 251,\n        columnNumber: 9\n      }\n    }), __jsx(Row, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 256,\n        columnNumber: 9\n      }\n    }, __jsx(Col, {\n      xs: 24,\n      sm: 24,\n      md: 12,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 257,\n        columnNumber: 11\n      }\n    }, __jsx(UpdateSatusForm, {\n      status: performer.streamingTitle,\n      updating: updating,\n      submit: this.handleUpdateStatusForm.bind(this),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 258,\n        columnNumber: 13\n      }\n    }), initialized && publish_started && __jsx(Button, {\n      type: \"text\",\n      style: {\n        background: 'black',\n        color: 'white'\n      },\n      onClick: this.stop.bind(this),\n      block: true,\n      className: \"mb-10\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 264,\n        columnNumber: 15\n      }\n    }, \"Stop Publishing\"), (!initialized || !publish_started) && __jsx(Button, {\n      type: \"primary\",\n      onClick: this.start.bind(this),\n      loading: loading,\n      block: true,\n      className: \"mb-10\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 275,\n        columnNumber: 15\n      }\n    }, \"Start Publishing\"), __jsx(LivePublisher, {\n      ref: ref => {\n        this.publisherRef = ref;\n      },\n      onChange: this.callback.bind(this),\n      configs: {\n        debug: true,\n        bandwidth: 900,\n        localVideoId: 'publisher'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 285,\n        columnNumber: 13\n      }\n    })), __jsx(Col, {\n      xs: 24,\n      sm: 24,\n      md: 12,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 297,\n        columnNumber: 11\n      }\n    }, __jsx(ChatBox, _extends({}, this.props, {\n      members: members,\n      totalParticipant: total,\n      currentPerformer: performer,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 298,\n        columnNumber: 13\n      }\n    })), (activeConversation === null || activeConversation === void 0 ? void 0 : activeConversation.data) && __jsx(\"div\", {\n      style: {\n        margin: '10px'\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 305,\n        columnNumber: 15\n      }\n    }, __jsx(Button, {\n      type: \"primary\",\n      onClick: this.removeAllMessage.bind(this),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 306,\n        columnNumber: 17\n      }\n    }, \"Clear message history\")))));\n  }\n\n}\n\n_defineProperty(PerformerLivePage, \"authenticate\", true);\n\nPerformerLivePage.contextType = SocketContext;\n\nconst mapStateToProps = state => ({\n  performer: state.performer.current,\n  updating: state.performer.updating,\n  updateSuccess: state.performer.updateSuccess,\n  updateError: state.performer.updateError,\n  activeConversation: state.streamMessage.activeConversation\n});\n\nconst mapDispatchs = {\n  updateStreamingStatus,\n  getStreamConversationSuccess,\n  loadStreamMessages,\n  resetStreamMessage,\n  resetAllStreamMessage\n};\nexport default connect(mapStateToProps, mapDispatchs)(PerformerLivePage);","map":null,"metadata":{},"sourceType":"module"}