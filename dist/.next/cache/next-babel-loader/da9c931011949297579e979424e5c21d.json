{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable no-nested-ternary */\nimport React, { PureComponent, createRef } from 'react';\nimport { connect } from 'react-redux';\nimport moment from 'moment';\nimport Link from 'next/link';\nimport './MessageList.less';\nimport { loadMoreStreamMessages, receiveStreamMessageSuccess, resetStreamMessage, deleteMessage, deleteMessageSuccess } from '@redux/stream-chat/actions';\nimport { SocketContext } from 'src/socket';\nimport Router from 'next/router';\nimport Compose from './Compose';\nimport Message from './Message';\n\nclass MessageList extends PureComponent {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"messagesRef\", void 0);\n\n    _defineProperty(this, \"state\", {\n      page: 1,\n      onloadmore: false\n    });\n\n    _defineProperty(this, \"onbeforeunload\", () => {\n      const {\n        conversation,\n        resetStreamMessage: dispatchResetStreamMessage\n      } = this.props;\n\n      if (conversation && conversation._id) {\n        dispatchResetStreamMessage();\n      }\n    });\n\n    _defineProperty(this, \"onMessage\", (message, type) => {\n      const {\n        receiveStreamMessageSuccess: dispatchReceiveStreamMessageSuccess,\n        deleteMessageSuccess: dispatchDeleteMessageSuccess\n      } = this.props;\n\n      if (!message) {\n        return;\n      }\n\n      type === 'created' && dispatchReceiveStreamMessageSuccess(message);\n      type === 'deleted' && dispatchDeleteMessageSuccess(message);\n    });\n\n    _defineProperty(this, \"onDelete\", messageId => {\n      const {\n        deleteMessage: dispatchDeleteMessage\n      } = this.props;\n      if (!messageId) return;\n      dispatchDeleteMessage({\n        messageId\n      });\n    });\n\n    _defineProperty(this, \"renderMessages\", () => {\n      const {\n        message,\n        currentUser,\n        currentPerformer,\n        conversation,\n        loggedIn\n      } = this.props;\n      const messages = message.items;\n      const {\n        fetching\n      } = message;\n      let i = 0;\n      const messageCount = messages && messages.length;\n\n      if (!messages.length && !fetching) {\n        const text = loggedIn ? 'There are no chat!' : __jsx(React.Fragment, null, \"There are no chat, please\", __jsx(Link, {\n          href: \"/auth/register\"\n        }, __jsx(\"a\", null, \" register \")), \"or\", __jsx(Link, {\n          href: \"/auth/login\"\n        }, __jsx(\"a\", null, \" login \")), \"to send message!\");\n        return __jsx(Message, {\n          data: {\n            isSystem: true,\n            text\n          }\n        });\n      }\n\n      const tempMessages = [];\n\n      while (i < messageCount) {\n        const previous = messages[i - 1];\n        const current = messages[i];\n        const next = messages[i + 1];\n        const userId = currentUser && currentUser._id ? currentUser._id : currentPerformer && currentPerformer._id ? currentPerformer._id : null;\n        const isMine = current.senderId === userId;\n        const currentMoment = moment(current.createdAt);\n        let prevBySameAuthor = false;\n        let nextBySameAuthor = false;\n        let startsSequence = true;\n        let endsSequence = true;\n        let showTimestamp = true;\n        const isOwner = conversation && conversation.performerId === current.senderId;\n        const canDelete = !current.isDeleted && currentPerformer && currentPerformer._id === conversation.performerId || !current.isDeleted && currentUser._id === current.senderId || !current.isDeleted && currentUser.roles && currentUser.roles.includes('admin');\n\n        if (previous) {\n          const previousMoment = moment(previous.createdAt);\n          const previousDuration = moment.duration(currentMoment.diff(previousMoment));\n          prevBySameAuthor = previous.senderId === current.senderId;\n\n          if (prevBySameAuthor && previousDuration.as('hours') < 1) {\n            startsSequence = false;\n          }\n\n          if (previousDuration.as('hours') < 1) {\n            showTimestamp = false;\n          }\n        }\n\n        if (next) {\n          const nextMoment = moment(next.createdAt);\n          const nextDuration = moment.duration(nextMoment.diff(currentMoment));\n          nextBySameAuthor = next.senderId === current.senderId;\n\n          if (nextBySameAuthor && nextDuration.as('hours') < 1) {\n            endsSequence = false;\n          }\n        }\n\n        if (current._id) {\n          tempMessages.push(__jsx(Message, {\n            onDelete: this.onDelete.bind(this, current._id),\n            canDelete: canDelete,\n            isOwner: isOwner,\n            key: i,\n            isMine: isMine,\n            startsSequence: startsSequence,\n            endsSequence: endsSequence,\n            showTimestamp: showTimestamp,\n            data: current\n          }));\n        } // Proceed to the next message.\n\n\n        i += 1;\n      }\n\n      this.scrollToBottom();\n      return tempMessages;\n    });\n\n    _defineProperty(this, \"rejoin\", () => {\n      const {\n        conversation\n      } = this.props;\n\n      if (conversation && conversation._id) {\n        const socket = this.context;\n        conversation.type === 'stream_public' && socket.emit('public-stream/rejoin', {\n          conversationId: conversation._id\n        });\n        (conversation.type === 'stream_group' || conversation.type === 'stream_private') && socket.emit('REJOIN_ROOM', {\n          conversationId: conversation._id\n        });\n      }\n    });\n  }\n\n  async componentDidMount() {\n    if (!this.messagesRef) this.messagesRef = /*#__PURE__*/createRef();\n    const {\n      conversation\n    } = this.props;\n    const socket = this.context;\n\n    if (conversation && conversation._id) {\n      socket && socket.on && socket.on(`message_created_conversation_${conversation._id}`, data => {\n        this.onMessage(data, 'created');\n      });\n      socket && socket.on && socket.on(`message_deleted_conversation_${conversation._id}`, data => {\n        this.onMessage(data, 'deleted');\n      });\n    }\n\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n    window.addEventListener('beforeunload', this.onbeforeunload);\n    this.reconnect();\n  }\n\n  componentWillUnmount() {\n    const {\n      conversation\n    } = this.props;\n    const socket = this.context;\n    socket && socket.off(`message_created_conversation_${conversation._id}`);\n    socket && socket.off(`message_deleted_conversation_${conversation._id}`);\n    socket && socket.off('reconnect', this.rejoin);\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n    window.addEventListener('beforeunload', this.onbeforeunload);\n  }\n\n  async handleScroll(conversation, event) {\n    const {\n      message,\n      isPublic,\n      loadMoreStreamMessages: dispatchLoadMoreStreamMessages\n    } = this.props;\n    const {\n      page\n    } = this.state;\n    const {\n      fetching,\n      items,\n      total\n    } = message;\n    const canloadmore = total > items.length;\n    const ele = event.target;\n    if (!canloadmore) return;\n\n    if (ele.scrollTop === 0 && conversation._id && !fetching && canloadmore) {\n      await this.setState({\n        page: page + 1,\n        onloadmore: true\n      });\n      dispatchLoadMoreStreamMessages({\n        conversationId: conversation._id,\n        type: conversation.type,\n        limit: 25,\n        offset: page * 25,\n        isPublic\n      });\n    }\n  }\n\n  scrollToBottom() {\n    const {\n      onloadmore\n    } = this.state;\n\n    if (onloadmore) {\n      return;\n    }\n\n    if (this.messagesRef && this.messagesRef.current) {\n      const ele = this.messagesRef.current;\n      window.setTimeout(() => {\n        ele.scroll({\n          top: ele.scrollHeight,\n          behavior: 'smooth'\n        });\n      }, 200);\n    }\n  }\n\n  reconnect() {\n    const socket = this.context;\n\n    if (socket) {\n      socket.on('reconnect', this.rejoin);\n    }\n  }\n\n  render() {\n    const {\n      conversation,\n      isPublic,\n      message\n    } = this.props;\n    const {\n      fetching\n    } = message;\n    if (!this.messagesRef) this.messagesRef = /*#__PURE__*/createRef();\n    return __jsx(\"div\", {\n      className: \"message-list\",\n      onScroll: this.handleScroll.bind(this, conversation)\n    }, conversation && conversation._id && __jsx(React.Fragment, null, __jsx(\"div\", {\n      className: \"message-list-container\",\n      ref: this.messagesRef\n    }, fetching && __jsx(\"p\", {\n      className: \"text-center\"\n    }, \"fetching...\"), this.renderMessages()), __jsx(Compose, {\n      conversation: conversation,\n      isPublic: isPublic\n    })));\n  }\n\n}\n\nMessageList.contextType = SocketContext;\n\nconst mapStates = state => {\n  const {\n    conversationMap,\n    activeConversation\n  } = state.streamMessage;\n  const messages = activeConversation.data && conversationMap[activeConversation.data._id] ? conversationMap[activeConversation.data._id].items || [] : [];\n  const totalMessages = activeConversation.data && conversationMap[activeConversation.data._id] ? conversationMap[activeConversation.data._id].total || 0 : 0;\n  const fetching = activeConversation.data && conversationMap[activeConversation.data._id] ? conversationMap[activeConversation.data._id].fetching || false : false;\n  return {\n    message: {\n      items: messages,\n      total: totalMessages,\n      fetching\n    },\n    conversation: activeConversation.data,\n    currentUser: state.user.current,\n    currentPerformer: state.performer.current,\n    loggedIn: state.auth.loggedIn\n  };\n};\n\nconst mapDispatch = {\n  loadMoreStreamMessages,\n  receiveStreamMessageSuccess,\n  deleteMessage,\n  deleteMessageSuccess,\n  resetStreamMessage\n};\nexport default connect(mapStates, mapDispatch)(MessageList);","map":{"version":3,"sources":["E:/WorkStation/Moldova/DTEST/src/components/stream-chat/MessageList.tsx"],"names":["React","PureComponent","createRef","connect","moment","Link","loadMoreStreamMessages","receiveStreamMessageSuccess","resetStreamMessage","deleteMessage","deleteMessageSuccess","SocketContext","Router","Compose","Message","MessageList","page","onloadmore","conversation","dispatchResetStreamMessage","props","_id","message","type","dispatchReceiveStreamMessageSuccess","dispatchDeleteMessageSuccess","messageId","dispatchDeleteMessage","currentUser","currentPerformer","loggedIn","messages","items","fetching","i","messageCount","length","text","isSystem","tempMessages","previous","current","next","userId","isMine","senderId","currentMoment","createdAt","prevBySameAuthor","nextBySameAuthor","startsSequence","endsSequence","showTimestamp","isOwner","performerId","canDelete","isDeleted","roles","includes","previousMoment","previousDuration","duration","diff","as","nextMoment","nextDuration","push","onDelete","bind","scrollToBottom","socket","context","emit","conversationId","componentDidMount","messagesRef","on","data","onMessage","events","onbeforeunload","window","addEventListener","reconnect","componentWillUnmount","off","rejoin","handleScroll","event","isPublic","dispatchLoadMoreStreamMessages","state","total","canloadmore","ele","target","scrollTop","setState","limit","offset","setTimeout","scroll","top","scrollHeight","behavior","render","renderMessages","contextType","mapStates","conversationMap","activeConversation","streamMessage","totalMessages","user","performer","auth","mapDispatch"],"mappings":"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","sourcesContent":["/* eslint-disable no-nested-ternary */\nimport React, { PureComponent, createRef } from 'react';\nimport { connect } from 'react-redux';\nimport moment from 'moment';\nimport Link from 'next/link';\nimport './MessageList.less';\nimport {\n  loadMoreStreamMessages,\n  receiveStreamMessageSuccess,\n  resetStreamMessage,\n  deleteMessage,\n  deleteMessageSuccess\n} from '@redux/stream-chat/actions';\nimport { SocketContext } from 'src/socket';\nimport { IUser, IPerformer } from 'src/interfaces';\nimport Router from 'next/router';\nimport Compose from './Compose';\nimport Message from './Message';\n\ninterface IProps {\n  loadMoreStreamMessages: Function;\n  receiveStreamMessageSuccess: Function;\n  message: any;\n  conversation: any;\n  currentUser: IUser;\n  currentPerformer: IPerformer;\n  isPublic?: boolean;\n  deleteMessage: Function;\n  deleteMessageSuccess: Function;\n  resetStreamMessage: Function;\n  loggedIn: boolean;\n}\nclass MessageList extends PureComponent<IProps> {\n  messagesRef: any;\n\n  state = {\n    page: 1,\n    onloadmore: false\n  };\n\n  async componentDidMount() {\n    if (!this.messagesRef) this.messagesRef = createRef();\n    const { conversation } = this.props;\n    const socket = this.context;\n    if (conversation && conversation._id) {\n      socket\n        && socket.on\n        && socket.on(\n          `message_created_conversation_${conversation._id}`,\n          (data) => {\n            this.onMessage(data, 'created');\n          }\n        );\n      socket\n        && socket.on\n        && socket.on(\n          `message_deleted_conversation_${conversation._id}`,\n          (data) => {\n            this.onMessage(data, 'deleted');\n          }\n        );\n    }\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n    window.addEventListener('beforeunload', this.onbeforeunload);\n    this.reconnect();\n  }\n\n  componentWillUnmount() {\n    const { conversation } = this.props;\n    const socket = this.context;\n    socket && socket.off(`message_created_conversation_${conversation._id}`);\n    socket && socket.off(`message_deleted_conversation_${conversation._id}`);\n    socket && socket.off('reconnect', this.rejoin);\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n    window.addEventListener('beforeunload', this.onbeforeunload);\n  }\n\n  async handleScroll(conversation, event) {\n    const {\n      message,\n      isPublic,\n      loadMoreStreamMessages: dispatchLoadMoreStreamMessages\n    } = this.props;\n    const { page } = this.state;\n    const { fetching, items, total } = message;\n    const canloadmore = total > items.length;\n    const ele = event.target;\n    if (!canloadmore) return;\n    if (ele.scrollTop === 0 && conversation._id && !fetching && canloadmore) {\n      await this.setState({ page: page + 1, onloadmore: true });\n      dispatchLoadMoreStreamMessages({\n        conversationId: conversation._id,\n        type: conversation.type,\n        limit: 25,\n        offset: page * 25,\n        isPublic\n      });\n    }\n  }\n\n  onbeforeunload = () => {\n    const { conversation, resetStreamMessage: dispatchResetStreamMessage } = this.props;\n    if (conversation && conversation._id) {\n      dispatchResetStreamMessage();\n    }\n  }\n\n  onMessage = (message, type) => {\n    const {\n      receiveStreamMessageSuccess: dispatchReceiveStreamMessageSuccess,\n      deleteMessageSuccess: dispatchDeleteMessageSuccess\n    } = this.props;\n    if (!message) {\n      return;\n    }\n    type === 'created' && dispatchReceiveStreamMessageSuccess(message);\n    type === 'deleted' && dispatchDeleteMessageSuccess(message);\n  };\n\n  onDelete = (messageId) => {\n    const { deleteMessage: dispatchDeleteMessage } = this.props;\n    if (!messageId) return;\n    dispatchDeleteMessage({ messageId });\n  };\n\n  renderMessages = () => {\n    const {\n      message,\n      currentUser,\n      currentPerformer,\n      conversation,\n      loggedIn\n    } = this.props;\n    const messages = message.items;\n    const { fetching } = message;\n    let i = 0;\n    const messageCount = messages && messages.length;\n    if (!messages.length && !fetching) {\n      const text = loggedIn ? (\n        'There are no chat!'\n      ) : (\n        <>\n          There are no chat, please\n          <Link href=\"/auth/register\">\n            <a> register </a>\n          </Link>\n          or\n          <Link href=\"/auth/login\">\n            <a> login </a>\n          </Link>\n          to send message!\n        </>\n      );\n      return <Message data={{ isSystem: true, text }} />;\n    }\n\n    const tempMessages = [];\n    while (i < messageCount) {\n      const previous = messages[i - 1];\n      const current = messages[i];\n      const next = messages[i + 1];\n      const userId = currentUser && currentUser._id\n        ? currentUser._id\n        : currentPerformer && currentPerformer._id\n          ? currentPerformer._id\n          : null;\n      const isMine = current.senderId === userId;\n      const currentMoment = moment(current.createdAt);\n      let prevBySameAuthor = false;\n      let nextBySameAuthor = false;\n      let startsSequence = true;\n      let endsSequence = true;\n      let showTimestamp = true;\n      const isOwner = conversation && conversation.performerId === current.senderId;\n      const canDelete = (!current.isDeleted\n          && currentPerformer\n          && currentPerformer._id === conversation.performerId)\n        || (!current.isDeleted && currentUser._id === current.senderId)\n        || (!current.isDeleted\n          && currentUser.roles\n          && currentUser.roles.includes('admin'));\n      if (previous) {\n        const previousMoment = moment(previous.createdAt);\n        const previousDuration = moment.duration(\n          currentMoment.diff(previousMoment)\n        );\n        prevBySameAuthor = previous.senderId === current.senderId;\n\n        if (prevBySameAuthor && previousDuration.as('hours') < 1) {\n          startsSequence = false;\n        }\n\n        if (previousDuration.as('hours') < 1) {\n          showTimestamp = false;\n        }\n      }\n\n      if (next) {\n        const nextMoment = moment(next.createdAt);\n        const nextDuration = moment.duration(nextMoment.diff(currentMoment));\n        nextBySameAuthor = next.senderId === current.senderId;\n\n        if (nextBySameAuthor && nextDuration.as('hours') < 1) {\n          endsSequence = false;\n        }\n      }\n      if (current._id) {\n        tempMessages.push(\n          <Message\n            onDelete={this.onDelete.bind(this, current._id)}\n            canDelete={canDelete}\n            isOwner={isOwner}\n            key={i}\n            isMine={isMine}\n            startsSequence={startsSequence}\n            endsSequence={endsSequence}\n            showTimestamp={showTimestamp}\n            data={current}\n          />\n        );\n      }\n      // Proceed to the next message.\n      i += 1;\n    }\n    this.scrollToBottom();\n    return tempMessages;\n  };\n\n  rejoin = () => {\n    const { conversation } = this.props;\n    if (conversation && conversation._id) {\n      const socket = this.context;\n      conversation.type === 'stream_public'\n        && socket.emit('public-stream/rejoin', {\n          conversationId: conversation._id\n        });\n      (conversation.type === 'stream_group'\n        || conversation.type === 'stream_private')\n        && socket.emit('REJOIN_ROOM', {\n          conversationId: conversation._id\n        });\n    }\n  };\n\n  scrollToBottom() {\n    const { onloadmore } = this.state;\n    if (onloadmore) {\n      return;\n    }\n    if (this.messagesRef && this.messagesRef.current) {\n      const ele: HTMLDivElement = this.messagesRef.current;\n      window.setTimeout(() => {\n        ele.scroll({\n          top: ele.scrollHeight,\n          behavior: 'smooth'\n        });\n      }, 200);\n    }\n  }\n\n  reconnect() {\n    const socket = this.context;\n    if (socket) {\n      socket.on('reconnect', this.rejoin);\n    }\n  }\n\n  render() {\n    const { conversation, isPublic, message } = this.props;\n    const { fetching } = message;\n    if (!this.messagesRef) this.messagesRef = createRef();\n    return (\n      <div\n        className=\"message-list\"\n        onScroll={this.handleScroll.bind(this, conversation)}\n      >\n        {conversation && conversation._id && (\n          <>\n            <div className=\"message-list-container\" ref={this.messagesRef}>\n              {fetching && <p className=\"text-center\">fetching...</p>}\n              {this.renderMessages()}\n            </div>\n            <Compose conversation={conversation} isPublic={isPublic} />\n          </>\n        )}\n      </div>\n    );\n  }\n}\n\nMessageList.contextType = SocketContext;\n\nconst mapStates = (state: any) => {\n  const { conversationMap, activeConversation } = state.streamMessage;\n  const messages = activeConversation.data && conversationMap[activeConversation.data._id]\n    ? conversationMap[activeConversation.data._id].items || []\n    : [];\n  const totalMessages = activeConversation.data && conversationMap[activeConversation.data._id]\n    ? conversationMap[activeConversation.data._id].total || 0\n    : 0;\n  const fetching = activeConversation.data && conversationMap[activeConversation.data._id]\n    ? conversationMap[activeConversation.data._id].fetching || false\n    : false;\n\n  return {\n    message: {\n      items: messages,\n      total: totalMessages,\n      fetching\n    },\n    conversation: activeConversation.data,\n    currentUser: state.user.current,\n    currentPerformer: state.performer.current,\n    loggedIn: state.auth.loggedIn\n  };\n};\n\nconst mapDispatch = {\n  loadMoreStreamMessages,\n  receiveStreamMessageSuccess,\n  deleteMessage,\n  deleteMessageSuccess,\n  resetStreamMessage\n};\n\nexport default connect(mapStates, mapDispatch)(MessageList);\n"]},"metadata":{},"sourceType":"module"}