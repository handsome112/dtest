{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/* eslint-disable camelcase */\nimport React from 'react';\nimport Router from 'next/router';\nimport { connect } from 'react-redux';\nimport { SETTING_KEYS } from 'src/constants';\nimport { message as message_ } from 'antd';\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from './constants';\nexport default function withAntmedia(WrappedComponent) {\n  var WebRTCAdaptor = /*#__PURE__*/function (_React$Component) {\n    _inherits(WebRTCAdaptor, _React$Component);\n\n    var _super = _createSuper(WebRTCAdaptor);\n\n    function WebRTCAdaptor(props) {\n      var _this;\n\n      _classCallCheck(this, WebRTCAdaptor);\n\n      _this = _super.call(this, props);\n\n      _defineProperty(_assertThisInitialized(_this), \"webRTCAdaptor\", void 0);\n\n      _defineProperty(_assertThisInitialized(_this), \"autoRepublishIntervalJob\", void 0);\n\n      _defineProperty(_assertThisInitialized(_this), \"initWebRTCAdaptorCallback\", void 0);\n\n      _defineProperty(_assertThisInitialized(_this), \"initWebRTCAdaptorCallbackError\", void 0);\n\n      _defineProperty(_assertThisInitialized(_this), \"onbeforeunload\", function () {\n        _this.leaveSession();\n      });\n\n      _this.state = {\n        initialized: false,\n        publish_started: false,\n        onTrack: null,\n        streamResolutions: [],\n        availableDevices: []\n      };\n      return _this;\n    }\n\n    _createClass(WebRTCAdaptor, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var initImmediately = this.props.initImmediately;\n        initImmediately && this.initWebRTCAdaptor();\n        Router.events.on('routeChangeStart', this.onbeforeunload); // window.addEventListener('beforeunload', this.onbeforeunload);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        Router.events.off('routeChangeStart', this.onbeforeunload); // window.removeEventListener('beforeunload', this.onbeforeunload);\n      }\n    }, {\n      key: \"getStreamInfo\",\n      value: function getStreamInfo(streamId) {\n        this.webRTCAdaptor && this.webRTCAdaptor.getStreamInfo(streamId);\n      }\n    }, {\n      key: \"getLiveStreamOrVodURL\",\n      value: function getLiveStreamOrVodURL() {}\n    }, {\n      key: \"forceStreamQuality\",\n      value: function forceStreamQuality(streamId) {\n        var streamHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        this.webRTCAdaptor && this.webRTCAdaptor.forceStreamQuality(streamId, streamHeight);\n      }\n    }, {\n      key: \"leaveSession\",\n      value: function leaveSession() {\n        var _this$state = this.state,\n            onTrack = _this$state.onTrack,\n            initialized = _this$state.initialized;\n        var isPlayMode = this.props.configs.isPlayMode;\n\n        if (this.autoRepublishIntervalJob) {\n          window.clearInterval(this.autoRepublishIntervalJob);\n          this.autoRepublishIntervalJob = null;\n        }\n\n        if (this.webRTCAdaptor) {\n          if (onTrack) {\n            this.webRTCAdaptor.stop(onTrack);\n            this.webRTCAdaptor.closePeerConnection(onTrack);\n          }\n\n          if (initialized) {\n            this.webRTCAdaptor.closeWebSocket();\n            !isPlayMode && this.webRTCAdaptor.closeStream();\n          }\n\n          this.webRTCAdaptor = null;\n        }\n\n        this.initWebRTCAdaptorCallback = null;\n        this.initWebRTCAdaptorCallbackError = null;\n        this.setState({\n          onTrack: null,\n          initialized: false,\n          streamResolutions: [],\n          availableDevices: []\n        });\n      }\n    }, {\n      key: \"initWebRTCAdaptor\",\n      value: function initWebRTCAdaptor(cb, cbError) {\n        var _this2 = this;\n\n        var _this$props = this.props,\n            configs = _this$props.configs,\n            settings = _this$props.settings,\n            autoRepublishDisabled = _this$props.autoRepublishDisabled,\n            onChange = _this$props.onChange;\n        var isPlayMode = configs.isPlayMode;\n        var publisherURL = isPlayMode ? settings[SETTING_KEYS.SUBSCRIBER_URL] : settings[SETTING_KEYS.PUBLISHER_URL];\n\n        if (!publisherURL) {\n          message_.error('Undefined WebsocketURL!');\n          return;\n        }\n\n        if (!this.webRTCAdaptor && autoRepublishDisabled) return;\n        var pc_config = {\n          iceServers: [{\n            urls: 'stun:stun.l.google.com:19302'\n          }]\n        };\n        var sdpConstraints = {\n          OfferToReceiveAudio: false,\n          OfferToReceiveVideo: false\n        };\n        var mediaConstraints = {\n          video: true,\n          audio: true\n        };\n        var appName = configs.appName || settings.AntMediaAppname;\n        var path = \"\".concat(publisherURL, \"/\").concat(appName, \"/websocket\");\n        var websocketURL = \"ws://\".concat(path);\n\n        if (window.location.protocol.startsWith('https')) {\n          websocketURL = \"wss://\".concat(path);\n        }\n\n        this.initWebRTCAdaptorCallback = cb;\n        this.initWebRTCAdaptorCallbackError = cbError; // eslint-disable-next-line dot-notation\n\n        this.webRTCAdaptor = new window['WebRTCAdaptor'](_objectSpread({\n          websocket_url: websocketURL,\n          mediaConstraints: mediaConstraints,\n          debug: process.env.NEXT_PUBLIC_DEBUG,\n          peerconnection_config: pc_config,\n          sdp_constraints: sdpConstraints,\n          bandwidth: parseInt(process.env.NEXT_PUBLIC_MAX_VIDEO_BITRATE_KBPS, 10) || 900,\n          isPlayMode: false,\n          callback: function callback(info, obj) {\n            if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n              _this2.setState({\n                initialized: true\n              });\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_STARTED) {\n              if (obj.streamId) {\n                _this2.setState({\n                  publish_started: true,\n                  onTrack: obj.streamId\n                });\n\n                if (!_this2.autoRepublishIntervalJob && !autoRepublishDisabled) {\n                  _this2.autoRepublishIntervalJob = setInterval(_this2.checkAndRepublishIfRequired.bind(_this2), 5000);\n                }\n\n                _this2.webRTCAdaptor && _this2.webRTCAdaptor.enableStats(obj.streamId);\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_FINISHED) {\n              _this2.setState({\n                publish_started: false,\n                onTrack: null\n              });\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.REFRESH_CONNECTION) {\n              var publish_started = _this2.state.publish_started;\n\n              if (publish_started && !autoRepublishDisabled) {\n                _this2.checkAndRepublishIfRequired();\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.ICE_CONNECTION_STATE_CHANGED) {\n              if (typeof obj !== 'undefined') {\n                // eslint-disable-next-line no-console\n                console.log('iceConnectionState Changed: ', JSON.stringify(obj));\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.UPDATED_STATS) {\n              if (typeof obj !== 'undefined') {\n                // eslint-disable-next-line no-console\n                console.log('Peer stats Changed: ', JSON.stringify(obj));\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.BITRATEMEASUREMENT) {\n              if (typeof obj !== 'undefined') {\n                // eslint-disable-next-line no-console\n                console.log('Bitrate Measurement: ', JSON.stringify(obj));\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_STARTED) {\n              if (obj.streamId) {\n                _this2.webRTCAdaptor && _this2.webRTCAdaptor.enableStats(obj.streamId);\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_FINISHED) {\n              _this2.setState({\n                streamResolutions: []\n              });\n\n              if (obj.streamId) {\n                _this2.webRTCAdaptor && _this2.webRTCAdaptor.disableStats(obj.streamId);\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.CLOSED) {\n              if (typeof obj !== 'undefined') {\n                // eslint-disable-next-line no-console\n                console.log(\"Connection closed: \".concat(JSON.stringify(obj)));\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.AVAILABLE_DEVICES) {\n              _this2.setState({\n                availableDevices: obj\n              });\n            }\n\n            onChange && typeof onChange === 'function' && onChange(info, obj);\n            cb && typeof cb === 'function' && cb(info, obj);\n          },\n          callbackError: function callbackError(error, message) {\n            cbError && typeof cbError === 'function' && cbError(error, message);\n\n            _this2.callbackError(error, message);\n          }\n        }, configs));\n      }\n    }, {\n      key: \"checkAndRepublishIfRequired\",\n      value: function checkAndRepublishIfRequired() {\n        try {\n          var onTrack = this.state.onTrack;\n          if (!this.webRTCAdaptor || !onTrack) return;\n          var iceState = this.webRTCAdaptor.iceConnectionState(onTrack);\n\n          if (iceState == null || iceState === 'failed' || iceState === 'disconnected') {\n            // eslint-disable-next-line no-console\n            console.error('Publish has stopped and will try to re-publish');\n            this.webRTCAdaptor.stop(onTrack);\n            this.webRTCAdaptor.closePeerConnection(onTrack);\n            this.webRTCAdaptor.closeWebSocket();\n            this.initWebRTCAdaptor(this.initWebRTCAdaptorCallback, this.initWebRTCAdaptorCallbackError);\n          }\n        } catch (e) {\n          // eslint-disable-next-line no-console\n          console.error('error republish', e);\n        }\n      }\n    }, {\n      key: \"callbackError\",\n      value: function callbackError(error, message) {\n        // some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError\n        // eslint-disable-next-line no-console\n        console.error(\"error callback: \".concat(JSON.stringify(error)));\n\n        if (typeof message === 'string') {\n          // eslint-disable-next-line no-console\n          console.error('error message:', message);\n          message_.error(message, 5);\n          return;\n        }\n\n        var errorMessage = JSON.stringify(error);\n\n        if (errorMessage.indexOf('noStreamNameSpecified') !== -1 || errorMessage.indexOf('no_stream_exist') !== -1 || errorMessage.indexOf('license_suspended_please_renew_license') !== -1 || errorMessage.indexOf('WebSocketNotConnected') !== -1) {\n          return;\n        }\n\n        if (errorMessage.indexOf('isTrusted') !== -1) {\n          this.leaveSession();\n          return;\n        }\n\n        if (errorMessage.indexOf('NotFoundError') !== -1) {\n          errorMessage = 'Camera or Mic are not found or not allowed in your device';\n        } else if (errorMessage.indexOf('NotReadableError') !== -1 || errorMessage.indexOf('TrackStartError') !== -1) {\n          errorMessage = 'Camera or Mic is being used by some other process that does not let read the devices';\n        } else if (errorMessage.indexOf('OverconstrainedError') !== -1 || errorMessage.indexOf('ConstraintNotSatisfiedError') !== -1) {\n          errorMessage = 'There is no device found that fits your video and audio constraints. You may change video and audio constraints';\n        } else if (errorMessage.indexOf('NotAllowedError') !== -1 || errorMessage.indexOf('PermissionDeniedError') !== -1) {\n          errorMessage = 'You are not allowed to access camera and mic.';\n        } else if (errorMessage.indexOf('TypeError') !== -1) {\n          errorMessage = 'Video/Audio is required';\n        } else if (errorMessage.indexOf('ScreenSharePermissionDenied') !== -1) {\n          errorMessage = 'You are not allowed to access screen share';\n        } else if (errorMessage.indexOf('unauthorized_access') !== -1) {\n          errorMessage = 'Access Denied. You don’t have permission to access';\n        } else if (errorMessage.indexOf('streamIdInUse') !== -1) {\n          errorMessage = 'Stream have been already published. Please close the previous connection.';\n        } else if (errorMessage.indexOf('publishTimeoutError') !== -1) {\n          errorMessage = 'WebRTC Publishing Timeout Error';\n          this.leaveSession();\n        } else if (errorMessage.indexOf('not_allowed_unregistered_streams') !== -1) {\n          errorMessage = 'Stream with an unregistered id is not allowed';\n        } else if (errorMessage.indexOf('UnsecureContext') !== -1) {\n          errorMessage = 'Fatal Error: Browser cannot access camera and mic because of unsecure context. Please install SSL and access via https';\n        } else if (errorMessage.indexOf('WebSocketNotSupported') !== -1) {\n          errorMessage = 'Fatal Error: WebSocket not supported in this browser';\n        } else if (errorMessage.indexOf('AudioAlreadyActive') !== -1) {\n          errorMessage = 'AudioAlreadyActive';\n        } else if (errorMessage.indexOf('stream_not_active_or_expired') !== -1) {\n          errorMessage = 'Stream is not active or expired';\n        } else if (errorMessage.indexOf('notSetRemoteDescription') !== -1) {\n          /*\n           * If getting codec incompatible or remote description error, should try to play HLS\n           */\n        } else if (errorMessage.indexOf('getUserMediaIsNotAllowed') !== -1) {\n          errorMessage = 'You are not allowed to reach devices from an insecure origin, please enable ssl';\n        } else {\n          errorMessage = 'Bad request!';\n        }\n\n        errorMessage && message_.error(errorMessage, 5);\n      }\n    }, {\n      key: \"muteLocalMic\",\n      value: function muteLocalMic() {\n        if (this.webRTCAdaptor) {\n          this.webRTCAdaptor.muteLocalMic();\n        }\n      }\n    }, {\n      key: \"unmuteLocalMic\",\n      value: function unmuteLocalMic() {\n        if (this.webRTCAdaptor) {\n          this.webRTCAdaptor.unmuteLocalMic();\n        }\n      }\n    }, {\n      key: \"startPublishing\",\n      value: function startPublishing(idOfStream) {\n        if (this.webRTCAdaptor) {\n          this.webRTCAdaptor.publish(idOfStream, null);\n        }\n      }\n    }, {\n      key: \"stopPublishing\",\n      value: function stopPublishing() {\n        if (this.autoRepublishIntervalJob) {\n          window.clearInterval(this.autoRepublishIntervalJob);\n          this.autoRepublishIntervalJob = null;\n        }\n\n        var onTrack = this.state.onTrack;\n        this.webRTCAdaptor && this.webRTCAdaptor.stop(onTrack);\n      }\n    }, {\n      key: \"fetchStream\",\n      value: function fetchStream(streamId, token) {\n        var extension = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'm3u8';\n        var cb = arguments.length > 3 ? arguments[3] : undefined;\n        var settings = this.props.settings;\n        var viewerURL = settings.viewerURL,\n            appName = settings.AntMediaAppname;\n        var src = \"\".concat(window.location.protocol, \"//\").concat(viewerURL, \"/\").concat(appName, \"/streams/\").concat(streamId, \"_adaptive.\").concat(extension, \"?token=\").concat(token);\n        fetch(src, {\n          method: 'HEAD'\n        }).then(function (response) {\n          if (response.status === 200) {\n            cb(null, src);\n          }\n\n          src = src.replace('_adaptive', '');\n          fetch(src, {\n            method: 'HEAD'\n          }) // eslint-disable-next-line no-shadow\n          .then(function (response) {\n            if (response.status === 200) {\n              cb(null, src);\n              return;\n            }\n\n            cb(response, null);\n          })[\"catch\"](function (err) {\n            cb(err, null);\n          });\n        })[\"catch\"](function (err) {\n          cb(err, null);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var forwardedRef = this.props.forwardedRef;\n        return __jsx(WrappedComponent, _extends({}, this.props, this.state, {\n          webRTCAdaptor: this.webRTCAdaptor,\n          initWebRTCAdaptor: this.initWebRTCAdaptor.bind(this),\n          muteLocalMic: this.muteLocalMic.bind(this),\n          unmuteLocalMic: this.unmuteLocalMic.bind(this),\n          leaveSession: this.leaveSession.bind(this),\n          getStreamInfo: this.getStreamInfo.bind(this),\n          forceStreamQuality: this.forceStreamQuality.bind(this),\n          startPublishing: this.startPublishing.bind(this),\n          stopPublishing: this.stopPublishing.bind(this),\n          fetchStream: this.fetchStream.bind(this),\n          ref: forwardedRef\n        }));\n      }\n    }], [{\n      key: \"getInitialProps\",\n      value: function () {\n        var _getInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ctx) {\n          var pageProps;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.t0 = WrappedComponent.getInitialProps;\n\n                  if (!_context.t0) {\n                    _context.next = 5;\n                    break;\n                  }\n\n                  _context.next = 4;\n                  return WrappedComponent.getInitialProps(ctx);\n\n                case 4:\n                  _context.t0 = _context.sent;\n\n                case 5:\n                  pageProps = _context.t0;\n                  return _context.abrupt(\"return\", _objectSpread({}, pageProps));\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        function getInitialProps(_x) {\n          return _getInitialProps.apply(this, arguments);\n        }\n\n        return getInitialProps;\n      }()\n    }]);\n\n    return WebRTCAdaptor;\n  }(React.Component);\n\n  var mapStateToProps = function mapStateToProps(state) {\n    return {\n      settings: state.streaming.settings\n    };\n  };\n\n  var WrapperComponent = hoistNonReactStatic(connect(mapStateToProps)(WebRTCAdaptor), WrappedComponent);\n  WrapperComponent.displayName = 'WrapperComponent';\n  var ForwadedRefWapper = /*#__PURE__*/React.forwardRef(function (props, ref) {\n    return __jsx(WrapperComponent, _extends({}, props, {\n      forwardedRef: ref\n    }));\n  });\n  ForwadedRefWapper.displayName = 'WebRTCAdaptor';\n  return ForwadedRefWapper;\n}","map":null,"metadata":{},"sourceType":"module"}