{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/* eslint-disable camelcase */\nimport React from 'react';\nimport Router from 'next/router';\nimport { connect } from 'react-redux';\nimport { SETTING_KEYS } from 'src/constants';\nimport { message as message_ } from 'antd';\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from './constants';\nexport default function withAntmedia(WrappedComponent) {\n  var WebRTCAdaptor = /*#__PURE__*/function (_React$Component) {\n    _inherits(WebRTCAdaptor, _React$Component);\n\n    var _super = _createSuper(WebRTCAdaptor);\n\n    function WebRTCAdaptor(props) {\n      var _this;\n\n      _classCallCheck(this, WebRTCAdaptor);\n\n      _this = _super.call(this, props);\n\n      _defineProperty(_assertThisInitialized(_this), \"webRTCAdaptor\", void 0);\n\n      _defineProperty(_assertThisInitialized(_this), \"autoRepublishIntervalJob\", void 0);\n\n      _defineProperty(_assertThisInitialized(_this), \"initWebRTCAdaptorCallback\", void 0);\n\n      _defineProperty(_assertThisInitialized(_this), \"initWebRTCAdaptorCallbackError\", void 0);\n\n      _defineProperty(_assertThisInitialized(_this), \"onbeforeunload\", function () {\n        _this.leaveSession();\n      });\n\n      _this.state = {\n        initialized: false,\n        publish_started: false,\n        onTrack: null,\n        streamResolutions: [],\n        availableDevices: []\n      };\n      return _this;\n    }\n\n    _createClass(WebRTCAdaptor, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var initImmediately = this.props.initImmediately;\n        initImmediately && this.initWebRTCAdaptor();\n        Router.events.on('routeChangeStart', this.onbeforeunload); // window.addEventListener('beforeunload', this.onbeforeunload);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        Router.events.off('routeChangeStart', this.onbeforeunload); // window.removeEventListener('beforeunload', this.onbeforeunload);\n      }\n    }, {\n      key: \"getStreamInfo\",\n      value: function getStreamInfo(streamId) {\n        this.webRTCAdaptor && this.webRTCAdaptor.getStreamInfo(streamId);\n      }\n    }, {\n      key: \"getLiveStreamOrVodURL\",\n      value: function getLiveStreamOrVodURL() {}\n    }, {\n      key: \"forceStreamQuality\",\n      value: function forceStreamQuality(streamId) {\n        var streamHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        this.webRTCAdaptor && this.webRTCAdaptor.forceStreamQuality(streamId, streamHeight);\n      }\n    }, {\n      key: \"leaveSession\",\n      value: function leaveSession() {\n        var _this$state = this.state,\n            onTrack = _this$state.onTrack,\n            initialized = _this$state.initialized;\n        var isPlayMode = this.props.configs.isPlayMode;\n\n        if (this.autoRepublishIntervalJob) {\n          window.clearInterval(this.autoRepublishIntervalJob);\n          this.autoRepublishIntervalJob = null;\n        }\n\n        if (this.webRTCAdaptor) {\n          if (onTrack) {\n            this.webRTCAdaptor.stop(onTrack);\n            this.webRTCAdaptor.closePeerConnection(onTrack);\n          }\n\n          if (initialized) {\n            this.webRTCAdaptor.closeWebSocket();\n            !isPlayMode && this.webRTCAdaptor.closeStream();\n          }\n\n          this.webRTCAdaptor = null;\n        }\n\n        this.initWebRTCAdaptorCallback = null;\n        this.initWebRTCAdaptorCallbackError = null;\n        this.setState({\n          onTrack: null,\n          initialized: false,\n          streamResolutions: [],\n          availableDevices: []\n        });\n      }\n    }, {\n      key: \"initWebRTCAdaptor\",\n      value: function initWebRTCAdaptor(cb, cbError) {\n        var _this2 = this;\n\n        var _this$props = this.props,\n            configs = _this$props.configs,\n            settings = _this$props.settings,\n            autoRepublishDisabled = _this$props.autoRepublishDisabled,\n            onChange = _this$props.onChange;\n        var isPlayMode = configs.isPlayMode;\n        var publisherURL = isPlayMode ? settings[SETTING_KEYS.SUBSCRIBER_URL] : settings[SETTING_KEYS.PUBLISHER_URL];\n\n        if (!publisherURL) {\n          message_.error('Undefined WebsocketURL!');\n          return;\n        }\n\n        if (!this.webRTCAdaptor && autoRepublishDisabled) return;\n        var pc_config = {\n          iceServers: [{\n            urls: 'stun:stun.l.google.com:19302'\n          }]\n        };\n        var sdpConstraints = {\n          OfferToReceiveAudio: false,\n          OfferToReceiveVideo: false\n        };\n        var mediaConstraints = {\n          video: true,\n          audio: true\n        };\n        var appName = configs.appName || settings.AntMediaAppname;\n        var path = \"\".concat(publisherURL, \"/\").concat(appName, \"/websocket\");\n        var websocketURL = \"ws://\".concat(path);\n\n        if (window.location.protocol.startsWith('https')) {\n          websocketURL = \"wss://\".concat(path);\n        }\n\n        this.initWebRTCAdaptorCallback = cb;\n        this.initWebRTCAdaptorCallbackError = cbError; // eslint-disable-next-line dot-notation\n\n        this.webRTCAdaptor = new window['WebRTCAdaptor'](_objectSpread({\n          websocket_url: websocketURL,\n          mediaConstraints: mediaConstraints,\n          debug: process.env.NEXT_PUBLIC_DEBUG,\n          peerconnection_config: pc_config,\n          sdp_constraints: sdpConstraints,\n          bandwidth: parseInt(process.env.NEXT_PUBLIC_MAX_VIDEO_BITRATE_KBPS, 10) || 900,\n          isPlayMode: false,\n          callback: function callback(info, obj) {\n            if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n              _this2.setState({\n                initialized: true\n              });\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_STARTED) {\n              if (obj.streamId) {\n                _this2.setState({\n                  publish_started: true,\n                  onTrack: obj.streamId\n                });\n\n                if (!_this2.autoRepublishIntervalJob && !autoRepublishDisabled) {\n                  _this2.autoRepublishIntervalJob = setInterval(_this2.checkAndRepublishIfRequired.bind(_this2), 5000);\n                }\n\n                _this2.webRTCAdaptor && _this2.webRTCAdaptor.enableStats(obj.streamId);\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_FINISHED) {\n              _this2.setState({\n                publish_started: false,\n                onTrack: null\n              });\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.REFRESH_CONNECTION) {\n              var publish_started = _this2.state.publish_started;\n\n              if (publish_started && !autoRepublishDisabled) {\n                _this2.checkAndRepublishIfRequired();\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.ICE_CONNECTION_STATE_CHANGED) {\n              if (typeof obj !== 'undefined') {\n                // eslint-disable-next-line no-console\n                console.log('iceConnectionState Changed: ', JSON.stringify(obj));\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.UPDATED_STATS) {\n              if (typeof obj !== 'undefined') {\n                // eslint-disable-next-line no-console\n                console.log('Peer stats Changed: ', JSON.stringify(obj));\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.BITRATEMEASUREMENT) {\n              if (typeof obj !== 'undefined') {\n                // eslint-disable-next-line no-console\n                console.log('Bitrate Measurement: ', JSON.stringify(obj));\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_STARTED) {\n              if (obj.streamId) {\n                _this2.webRTCAdaptor && _this2.webRTCAdaptor.enableStats(obj.streamId);\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_FINISHED) {\n              _this2.setState({\n                streamResolutions: []\n              });\n\n              if (obj.streamId) {\n                _this2.webRTCAdaptor && _this2.webRTCAdaptor.disableStats(obj.streamId);\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.CLOSED) {\n              if (typeof obj !== 'undefined') {\n                // eslint-disable-next-line no-console\n                console.log(\"Connection closed: \".concat(JSON.stringify(obj)));\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.AVAILABLE_DEVICES) {\n              _this2.setState({\n                availableDevices: obj\n              });\n            }\n\n            onChange && typeof onChange === 'function' && onChange(info, obj);\n            cb && typeof cb === 'function' && cb(info, obj);\n          },\n          callbackError: function callbackError(error, message) {\n            cbError && typeof cbError === 'function' && cbError(error, message);\n\n            _this2.callbackError(error, message);\n          }\n        }, configs));\n      }\n    }, {\n      key: \"checkAndRepublishIfRequired\",\n      value: function checkAndRepublishIfRequired() {\n        try {\n          var onTrack = this.state.onTrack;\n          if (!this.webRTCAdaptor || !onTrack) return;\n          var iceState = this.webRTCAdaptor.iceConnectionState(onTrack);\n\n          if (iceState == null || iceState === 'failed' || iceState === 'disconnected') {\n            // eslint-disable-next-line no-console\n            console.error('Publish has stopped and will try to re-publish');\n            this.webRTCAdaptor.stop(onTrack);\n            this.webRTCAdaptor.closePeerConnection(onTrack);\n            this.webRTCAdaptor.closeWebSocket();\n            this.initWebRTCAdaptor(this.initWebRTCAdaptorCallback, this.initWebRTCAdaptorCallbackError);\n          }\n        } catch (e) {\n          // eslint-disable-next-line no-console\n          console.error('error republish', e);\n        }\n      }\n    }, {\n      key: \"callbackError\",\n      value: function callbackError(error, message) {\n        // some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError\n        // eslint-disable-next-line no-console\n        console.error(\"error callback: \".concat(JSON.stringify(error)));\n\n        if (typeof message === 'string') {\n          // eslint-disable-next-line no-console\n          console.error('error message:', message);\n          message_.error(message, 5);\n          return;\n        }\n\n        var errorMessage = JSON.stringify(error);\n\n        if (errorMessage.indexOf('noStreamNameSpecified') !== -1 || errorMessage.indexOf('no_stream_exist') !== -1 || errorMessage.indexOf('license_suspended_please_renew_license') !== -1 || errorMessage.indexOf('WebSocketNotConnected') !== -1) {\n          return;\n        }\n\n        if (errorMessage.indexOf('isTrusted') !== -1) {\n          this.leaveSession();\n          return;\n        }\n\n        if (errorMessage.indexOf('NotFoundError') !== -1) {\n          errorMessage = 'Camera or Mic are not found or not allowed in your device';\n        } else if (errorMessage.indexOf('NotReadableError') !== -1 || errorMessage.indexOf('TrackStartError') !== -1) {\n          errorMessage = 'Camera or Mic is being used by some other process that does not let read the devices';\n        } else if (errorMessage.indexOf('OverconstrainedError') !== -1 || errorMessage.indexOf('ConstraintNotSatisfiedError') !== -1) {\n          errorMessage = 'There is no device found that fits your video and audio constraints. You may change video and audio constraints';\n        } else if (errorMessage.indexOf('NotAllowedError') !== -1 || errorMessage.indexOf('PermissionDeniedError') !== -1) {\n          errorMessage = 'You are not allowed to access camera and mic.';\n        } else if (errorMessage.indexOf('TypeError') !== -1) {\n          errorMessage = 'Video/Audio is required';\n        } else if (errorMessage.indexOf('ScreenSharePermissionDenied') !== -1) {\n          errorMessage = 'You are not allowed to access screen share';\n        } else if (errorMessage.indexOf('unauthorized_access') !== -1) {\n          errorMessage = 'Access Denied. You don’t have permission to access';\n        } else if (errorMessage.indexOf('streamIdInUse') !== -1) {\n          errorMessage = 'Stream have been already published. Please close the previous connection.';\n        } else if (errorMessage.indexOf('publishTimeoutError') !== -1) {\n          errorMessage = 'WebRTC Publishing Timeout Error';\n          this.leaveSession();\n        } else if (errorMessage.indexOf('not_allowed_unregistered_streams') !== -1) {\n          errorMessage = 'Stream with an unregistered id is not allowed';\n        } else if (errorMessage.indexOf('UnsecureContext') !== -1) {\n          errorMessage = 'Fatal Error: Browser cannot access camera and mic because of unsecure context. Please install SSL and access via https';\n        } else if (errorMessage.indexOf('WebSocketNotSupported') !== -1) {\n          errorMessage = 'Fatal Error: WebSocket not supported in this browser';\n        } else if (errorMessage.indexOf('AudioAlreadyActive') !== -1) {\n          errorMessage = 'AudioAlreadyActive';\n        } else if (errorMessage.indexOf('stream_not_active_or_expired') !== -1) {\n          errorMessage = 'Stream is not active or expired';\n        } else if (errorMessage.indexOf('notSetRemoteDescription') !== -1) {\n          /*\n           * If getting codec incompatible or remote description error, should try to play HLS\n           */\n        } else if (errorMessage.indexOf('getUserMediaIsNotAllowed') !== -1) {\n          errorMessage = 'You are not allowed to reach devices from an insecure origin, please enable ssl';\n        } else {\n          errorMessage = 'Bad request!';\n        }\n\n        errorMessage && message_.error(errorMessage, 5);\n      }\n    }, {\n      key: \"muteLocalMic\",\n      value: function muteLocalMic() {\n        if (this.webRTCAdaptor) {\n          this.webRTCAdaptor.muteLocalMic();\n        }\n      }\n    }, {\n      key: \"unmuteLocalMic\",\n      value: function unmuteLocalMic() {\n        if (this.webRTCAdaptor) {\n          this.webRTCAdaptor.unmuteLocalMic();\n        }\n      }\n    }, {\n      key: \"startPublishing\",\n      value: function startPublishing(idOfStream) {\n        if (this.webRTCAdaptor) {\n          this.webRTCAdaptor.publish(idOfStream, null);\n        }\n      }\n    }, {\n      key: \"stopPublishing\",\n      value: function stopPublishing() {\n        if (this.autoRepublishIntervalJob) {\n          window.clearInterval(this.autoRepublishIntervalJob);\n          this.autoRepublishIntervalJob = null;\n        }\n\n        var onTrack = this.state.onTrack;\n        this.webRTCAdaptor && this.webRTCAdaptor.stop(onTrack);\n      }\n    }, {\n      key: \"fetchStream\",\n      value: function fetchStream(streamId, token) {\n        var extension = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'm3u8';\n        var cb = arguments.length > 3 ? arguments[3] : undefined;\n        var settings = this.props.settings;\n        var viewerURL = settings.viewerURL,\n            appName = settings.AntMediaAppname;\n        var src = \"\".concat(window.location.protocol, \"//\").concat(viewerURL, \"/\").concat(appName, \"/streams/\").concat(streamId, \"_adaptive.\").concat(extension, \"?token=\").concat(token);\n        fetch(src, {\n          method: 'HEAD'\n        }).then(function (response) {\n          if (response.status === 200) {\n            cb(null, src);\n          }\n\n          src = src.replace('_adaptive', '');\n          fetch(src, {\n            method: 'HEAD'\n          }) // eslint-disable-next-line no-shadow\n          .then(function (response) {\n            if (response.status === 200) {\n              cb(null, src);\n              return;\n            }\n\n            cb(response, null);\n          })[\"catch\"](function (err) {\n            cb(err, null);\n          });\n        })[\"catch\"](function (err) {\n          cb(err, null);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var forwardedRef = this.props.forwardedRef;\n        return __jsx(WrappedComponent, _extends({}, this.props, this.state, {\n          webRTCAdaptor: this.webRTCAdaptor,\n          initWebRTCAdaptor: this.initWebRTCAdaptor.bind(this),\n          muteLocalMic: this.muteLocalMic.bind(this),\n          unmuteLocalMic: this.unmuteLocalMic.bind(this),\n          leaveSession: this.leaveSession.bind(this),\n          getStreamInfo: this.getStreamInfo.bind(this),\n          forceStreamQuality: this.forceStreamQuality.bind(this),\n          startPublishing: this.startPublishing.bind(this),\n          stopPublishing: this.stopPublishing.bind(this),\n          fetchStream: this.fetchStream.bind(this),\n          ref: forwardedRef\n        }));\n      }\n    }], [{\n      key: \"getInitialProps\",\n      value: function () {\n        var _getInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ctx) {\n          var pageProps;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.t0 = WrappedComponent.getInitialProps;\n\n                  if (!_context.t0) {\n                    _context.next = 5;\n                    break;\n                  }\n\n                  _context.next = 4;\n                  return WrappedComponent.getInitialProps(ctx);\n\n                case 4:\n                  _context.t0 = _context.sent;\n\n                case 5:\n                  pageProps = _context.t0;\n                  return _context.abrupt(\"return\", _objectSpread({}, pageProps));\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        function getInitialProps(_x) {\n          return _getInitialProps.apply(this, arguments);\n        }\n\n        return getInitialProps;\n      }()\n    }]);\n\n    return WebRTCAdaptor;\n  }(React.Component);\n\n  var mapStateToProps = function mapStateToProps(state) {\n    return {\n      settings: state.streaming.settings\n    };\n  };\n\n  var WrapperComponent = hoistNonReactStatic(connect(mapStateToProps)(WebRTCAdaptor), WrappedComponent);\n  WrapperComponent.displayName = 'WrapperComponent';\n  var ForwadedRefWapper = /*#__PURE__*/React.forwardRef(function (props, ref) {\n    return __jsx(WrapperComponent, _extends({}, props, {\n      forwardedRef: ref\n    }));\n  });\n  ForwadedRefWapper.displayName = 'WebRTCAdaptor';\n  return ForwadedRefWapper;\n}","map":{"version":3,"sources":["E:/WorkStation/Moldova/DTEST/src/antmedia/index.tsx"],"names":["React","Router","connect","SETTING_KEYS","message","message_","hoistNonReactStatic","WEBRTC_ADAPTOR_INFORMATIONS","withAntmedia","WrappedComponent","WebRTCAdaptor","props","leaveSession","state","initialized","publish_started","onTrack","streamResolutions","availableDevices","initImmediately","initWebRTCAdaptor","events","on","onbeforeunload","off","streamId","webRTCAdaptor","getStreamInfo","streamHeight","forceStreamQuality","isPlayMode","configs","autoRepublishIntervalJob","window","clearInterval","stop","closePeerConnection","closeWebSocket","closeStream","initWebRTCAdaptorCallback","initWebRTCAdaptorCallbackError","setState","cb","cbError","settings","autoRepublishDisabled","onChange","publisherURL","SUBSCRIBER_URL","PUBLISHER_URL","error","pc_config","iceServers","urls","sdpConstraints","OfferToReceiveAudio","OfferToReceiveVideo","mediaConstraints","video","audio","appName","AntMediaAppname","path","websocketURL","location","protocol","startsWith","websocket_url","debug","process","env","NEXT_PUBLIC_DEBUG","peerconnection_config","sdp_constraints","bandwidth","parseInt","NEXT_PUBLIC_MAX_VIDEO_BITRATE_KBPS","callback","info","obj","INITIALIZED","PUBLISH_STARTED","setInterval","checkAndRepublishIfRequired","bind","enableStats","PUBLISH_FINISHED","REFRESH_CONNECTION","ICE_CONNECTION_STATE_CHANGED","console","log","JSON","stringify","UPDATED_STATS","BITRATEMEASUREMENT","PLAY_STARTED","PLAY_FINISHED","disableStats","CLOSED","AVAILABLE_DEVICES","callbackError","iceState","iceConnectionState","e","errorMessage","indexOf","muteLocalMic","unmuteLocalMic","idOfStream","publish","token","extension","viewerURL","src","fetch","method","then","response","status","replace","err","forwardedRef","startPublishing","stopPublishing","fetchStream","ctx","getInitialProps","pageProps","Component","mapStateToProps","streaming","WrapperComponent","displayName","ForwadedRefWapper","forwardRef","ref"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\nimport React from 'react';\nimport Router from 'next/router';\nimport { connect } from 'react-redux';\nimport { StreamSettings } from 'src/interfaces';\nimport { SETTING_KEYS } from 'src/constants';\nimport { message as message_ } from 'antd';\nimport { NextComponentType, NextPageContext } from 'next';\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from './constants';\nimport {\n  WebRTCAdaptorConfigs,\n  WebRTCAdaptorCallback,\n  WebRTCAdaptorCallbackError,\n  IWebRTCAdaptor,\n  WebRTCAdaptorProps,\n  Device\n} from './interfaces';\n\ninterface IProps {\n  configs: Partial<WebRTCAdaptorConfigs>;\n  settings: StreamSettings;\n  classNames?: string;\n  containerClassName?: string;\n  forwardedRef?: any;\n  initImmediately?: boolean;\n  autoRepublishDisabled?: boolean;\n  onClick?: any;\n  onChange?: WebRTCAdaptorCallback;\n}\n\ninterface IStates {\n  initialized: boolean;\n  publish_started: boolean;\n  streamResolutions: number[];\n  onTrack: string;\n  availableDevices: Device[];\n}\n\ntype WrappedComponentProps = React.ComponentProps<\n  React.ComponentClass<\n    Partial<IProps & WebRTCAdaptorProps & React.RefAttributes<any>>\n  >\n>;\n\nexport default function withAntmedia<P = any>(\n  WrappedComponent: NextComponentType<\n    NextPageContext,\n    any,\n    WrappedComponentProps\n  >\n) {\n  class WebRTCAdaptor extends React.Component<IProps, IStates> {\n    private webRTCAdaptor: IWebRTCAdaptor;\n\n    private autoRepublishIntervalJob: NodeJS.Timeout;\n\n    private initWebRTCAdaptorCallback: WebRTCAdaptorCallback;\n\n    private initWebRTCAdaptorCallbackError: WebRTCAdaptorCallbackError;\n\n    static async getInitialProps(ctx: NextPageContext) {\n      const pageProps = WrappedComponent.getInitialProps\n        && (await WrappedComponent.getInitialProps(ctx));\n      // Return props.\n      return { ...pageProps };\n    }\n\n    constructor(props: IProps) {\n      super(props);\n      this.state = {\n        initialized: false,\n        publish_started: false,\n        onTrack: null,\n        streamResolutions: [],\n        availableDevices: []\n      };\n    }\n\n    componentDidMount() {\n      const { initImmediately } = this.props;\n      initImmediately && this.initWebRTCAdaptor();\n      Router.events.on('routeChangeStart', this.onbeforeunload);\n      // window.addEventListener('beforeunload', this.onbeforeunload);\n    }\n\n    componentWillUnmount() {\n      Router.events.off('routeChangeStart', this.onbeforeunload);\n      // window.removeEventListener('beforeunload', this.onbeforeunload);\n    }\n\n    onbeforeunload = () => {\n      this.leaveSession();\n    };\n\n    getStreamInfo(streamId: string) {\n      this.webRTCAdaptor && this.webRTCAdaptor.getStreamInfo(streamId);\n    }\n\n    getLiveStreamOrVodURL() {}\n\n    forceStreamQuality(streamId: string, streamHeight = 0) {\n      this.webRTCAdaptor\n        && this.webRTCAdaptor.forceStreamQuality(streamId, streamHeight);\n    }\n\n    leaveSession() {\n      const { onTrack, initialized } = this.state;\n      const {\n        configs: { isPlayMode }\n      } = this.props;\n      if (this.autoRepublishIntervalJob) {\n        window.clearInterval(this.autoRepublishIntervalJob);\n        this.autoRepublishIntervalJob = null;\n      }\n\n      if (this.webRTCAdaptor) {\n        if (onTrack) {\n          this.webRTCAdaptor.stop(onTrack);\n          this.webRTCAdaptor.closePeerConnection(onTrack);\n        }\n        if (initialized) {\n          this.webRTCAdaptor.closeWebSocket();\n          !isPlayMode && this.webRTCAdaptor.closeStream();\n        }\n        this.webRTCAdaptor = null;\n      }\n\n      this.initWebRTCAdaptorCallback = null;\n      this.initWebRTCAdaptorCallbackError = null;\n      this.setState({\n        onTrack: null,\n        initialized: false,\n        streamResolutions: [],\n        availableDevices: []\n      });\n    }\n\n    initWebRTCAdaptor(\n      cb?: WebRTCAdaptorCallback,\n      cbError?: WebRTCAdaptorCallbackError\n    ) {\n      const {\n        configs, settings, autoRepublishDisabled, onChange\n      } = this.props;\n      const { isPlayMode } = configs;\n      const publisherURL = isPlayMode\n        ? settings[SETTING_KEYS.SUBSCRIBER_URL]\n        : settings[SETTING_KEYS.PUBLISHER_URL];\n      if (!publisherURL) {\n        message_.error('Undefined WebsocketURL!');\n        return;\n      }\n\n      if (!this.webRTCAdaptor && autoRepublishDisabled) return;\n\n      const pc_config = {\n        iceServers: [\n          {\n            urls: 'stun:stun.l.google.com:19302'\n          }\n        ]\n      };\n\n      const sdpConstraints = {\n        OfferToReceiveAudio: false,\n        OfferToReceiveVideo: false\n      };\n\n      const mediaConstraints = {\n        video: true,\n        audio: true\n      };\n\n      const appName = configs.appName || settings.AntMediaAppname;\n      const path = `${publisherURL}/${appName}/websocket`;\n\n      let websocketURL = `ws://${path}`;\n\n      if (window.location.protocol.startsWith('https')) {\n        websocketURL = `wss://${path}`;\n      }\n\n      this.initWebRTCAdaptorCallback = cb;\n      this.initWebRTCAdaptorCallbackError = cbError;\n      // eslint-disable-next-line dot-notation\n      this.webRTCAdaptor = new window['WebRTCAdaptor']({\n        websocket_url: websocketURL,\n        mediaConstraints,\n        debug: process.env.NEXT_PUBLIC_DEBUG,\n        peerconnection_config: pc_config,\n        sdp_constraints: sdpConstraints,\n        bandwidth: parseInt(process.env.NEXT_PUBLIC_MAX_VIDEO_BITRATE_KBPS, 10) || 900,\n        isPlayMode: false,\n        callback: (info: WEBRTC_ADAPTOR_INFORMATIONS, obj: any) => {\n          if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n            this.setState({ initialized: true });\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_STARTED) {\n            if (obj.streamId) {\n              this.setState({\n                publish_started: true,\n                onTrack: obj.streamId\n              });\n              if (!this.autoRepublishIntervalJob && !autoRepublishDisabled) {\n                this.autoRepublishIntervalJob = setInterval(\n                  this.checkAndRepublishIfRequired.bind(this),\n                  5000\n                );\n              }\n              this.webRTCAdaptor && this.webRTCAdaptor.enableStats(obj.streamId);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_FINISHED) {\n            this.setState({ publish_started: false, onTrack: null });\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.REFRESH_CONNECTION) {\n            const { publish_started } = this.state;\n            if (publish_started && !autoRepublishDisabled) {\n              this.checkAndRepublishIfRequired();\n            }\n          } else if (\n            info === WEBRTC_ADAPTOR_INFORMATIONS.ICE_CONNECTION_STATE_CHANGED\n          ) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log('iceConnectionState Changed: ', JSON.stringify(obj));\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.UPDATED_STATS) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log('Peer stats Changed: ', JSON.stringify(obj));\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.BITRATEMEASUREMENT) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log('Bitrate Measurement: ', JSON.stringify(obj));\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_STARTED) {\n            if (obj.streamId) {\n              this.webRTCAdaptor && this.webRTCAdaptor.enableStats(obj.streamId);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_FINISHED) {\n            this.setState({ streamResolutions: [] });\n            if (obj.streamId) {\n              this.webRTCAdaptor && this.webRTCAdaptor.disableStats(obj.streamId);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.CLOSED) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log(`Connection closed: ${JSON.stringify(obj)}`);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.AVAILABLE_DEVICES) {\n            this.setState({ availableDevices: obj });\n          }\n\n          onChange && typeof onChange === 'function' && onChange(info, obj);\n          cb && typeof cb === 'function' && cb(info, obj);\n        },\n        callbackError: (error, message) => {\n          cbError && typeof cbError === 'function' && cbError(error, message);\n          this.callbackError(error, message);\n        },\n        ...configs\n      });\n    }\n\n    checkAndRepublishIfRequired() {\n      try {\n        const { onTrack } = this.state;\n        if (!this.webRTCAdaptor || !onTrack) return;\n\n        const iceState = this.webRTCAdaptor.iceConnectionState(onTrack);\n        if (\n          iceState == null\n          || iceState === 'failed'\n          || iceState === 'disconnected'\n        ) {\n          // eslint-disable-next-line no-console\n          console.error('Publish has stopped and will try to re-publish');\n          this.webRTCAdaptor.stop(onTrack);\n          this.webRTCAdaptor.closePeerConnection(onTrack);\n          this.webRTCAdaptor.closeWebSocket();\n          this.initWebRTCAdaptor(\n            this.initWebRTCAdaptorCallback,\n            this.initWebRTCAdaptorCallbackError\n          );\n        }\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.error('error republish', e);\n      }\n    }\n\n    callbackError(error, message) {\n      // some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError\n      // eslint-disable-next-line no-console\n      console.error(`error callback: ${JSON.stringify(error)}`);\n      if (typeof message === 'string') {\n        // eslint-disable-next-line no-console\n        console.error('error message:', message);\n        message_.error(message, 5);\n        return;\n      }\n\n      let errorMessage = JSON.stringify(error);\n      if (\n        errorMessage.indexOf('noStreamNameSpecified') !== -1\n        || errorMessage.indexOf('no_stream_exist') !== -1\n        || errorMessage.indexOf('license_suspended_please_renew_license') !== -1\n        || errorMessage.indexOf('WebSocketNotConnected') !== -1\n      ) {\n        return;\n      }\n\n      if (errorMessage.indexOf('isTrusted') !== -1) {\n        this.leaveSession();\n        return;\n      }\n\n      if (errorMessage.indexOf('NotFoundError') !== -1) {\n        errorMessage = 'Camera or Mic are not found or not allowed in your device';\n      } else if (\n        errorMessage.indexOf('NotReadableError') !== -1\n        || errorMessage.indexOf('TrackStartError') !== -1\n      ) {\n        errorMessage = 'Camera or Mic is being used by some other process that does not let read the devices';\n      } else if (\n        errorMessage.indexOf('OverconstrainedError') !== -1\n        || errorMessage.indexOf('ConstraintNotSatisfiedError') !== -1\n      ) {\n        errorMessage = 'There is no device found that fits your video and audio constraints. You may change video and audio constraints';\n      } else if (\n        errorMessage.indexOf('NotAllowedError') !== -1\n        || errorMessage.indexOf('PermissionDeniedError') !== -1\n      ) {\n        errorMessage = 'You are not allowed to access camera and mic.';\n      } else if (errorMessage.indexOf('TypeError') !== -1) {\n        errorMessage = 'Video/Audio is required';\n      } else if (errorMessage.indexOf('ScreenSharePermissionDenied') !== -1) {\n        errorMessage = 'You are not allowed to access screen share';\n      } else if (errorMessage.indexOf('unauthorized_access') !== -1) {\n        errorMessage = 'Access Denied. You don’t have permission to access';\n      } else if (errorMessage.indexOf('streamIdInUse') !== -1) {\n        errorMessage = 'Stream have been already published. Please close the previous connection.';\n      } else if (errorMessage.indexOf('publishTimeoutError') !== -1) {\n        errorMessage = 'WebRTC Publishing Timeout Error';\n        this.leaveSession();\n      } else if (\n        errorMessage.indexOf('not_allowed_unregistered_streams') !== -1\n      ) {\n        errorMessage = 'Stream with an unregistered id is not allowed';\n      } else if (errorMessage.indexOf('UnsecureContext') !== -1) {\n        errorMessage = 'Fatal Error: Browser cannot access camera and mic because of unsecure context. Please install SSL and access via https';\n      } else if (errorMessage.indexOf('WebSocketNotSupported') !== -1) {\n        errorMessage = 'Fatal Error: WebSocket not supported in this browser';\n      } else if (errorMessage.indexOf('AudioAlreadyActive') !== -1) {\n        errorMessage = 'AudioAlreadyActive';\n      } else if (errorMessage.indexOf('stream_not_active_or_expired') !== -1) {\n        errorMessage = 'Stream is not active or expired';\n      } else if (errorMessage.indexOf('notSetRemoteDescription') !== -1) {\n        /*\n         * If getting codec incompatible or remote description error, should try to play HLS\n         */\n      } else if (errorMessage.indexOf('getUserMediaIsNotAllowed') !== -1) {\n        errorMessage = 'You are not allowed to reach devices from an insecure origin, please enable ssl';\n      } else {\n        errorMessage = 'Bad request!';\n      }\n\n      errorMessage && message_.error(errorMessage, 5);\n    }\n\n    muteLocalMic() {\n      if (this.webRTCAdaptor) {\n        this.webRTCAdaptor.muteLocalMic();\n      }\n    }\n\n    unmuteLocalMic() {\n      if (this.webRTCAdaptor) {\n        this.webRTCAdaptor.unmuteLocalMic();\n      }\n    }\n\n    startPublishing(idOfStream: string) {\n      if (this.webRTCAdaptor) {\n        this.webRTCAdaptor.publish(idOfStream, null);\n      }\n    }\n\n    stopPublishing() {\n      if (this.autoRepublishIntervalJob) {\n        window.clearInterval(this.autoRepublishIntervalJob);\n        this.autoRepublishIntervalJob = null;\n      }\n\n      const { onTrack } = this.state;\n      this.webRTCAdaptor && this.webRTCAdaptor.stop(onTrack);\n    }\n\n    fetchStream(\n      streamId: string,\n      token: string,\n      extension = 'm3u8',\n      cb: (error: any, src: string) => void\n    ) {\n      const { settings } = this.props;\n      const { viewerURL, AntMediaAppname: appName } = settings;\n      let src = `${window.location.protocol}//${viewerURL}/${appName}/streams/${streamId}_adaptive.${extension}?token=${token}`;\n      fetch(src, { method: 'HEAD' })\n        .then((response) => {\n          if (response.status === 200) {\n            cb(null, src);\n          }\n\n          src = src.replace('_adaptive', '');\n          fetch(src, { method: 'HEAD' })\n            // eslint-disable-next-line no-shadow\n            .then((response) => {\n              if (response.status === 200) {\n                cb(null, src);\n                return;\n              }\n\n              cb(response, null);\n            })\n            .catch((err) => {\n              cb(err, null);\n            });\n        })\n        .catch((err) => {\n          cb(err, null);\n        });\n    }\n\n    render() {\n      const { forwardedRef } = this.props;\n      return (\n        <WrappedComponent\n          {...this.props}\n          {...this.state}\n          webRTCAdaptor={this.webRTCAdaptor}\n          initWebRTCAdaptor={this.initWebRTCAdaptor.bind(this)}\n          muteLocalMic={this.muteLocalMic.bind(this)}\n          unmuteLocalMic={this.unmuteLocalMic.bind(this)}\n          leaveSession={this.leaveSession.bind(this)}\n          getStreamInfo={this.getStreamInfo.bind(this)}\n          forceStreamQuality={this.forceStreamQuality.bind(this)}\n          startPublishing={this.startPublishing.bind(this)}\n          stopPublishing={this.stopPublishing.bind(this)}\n          fetchStream={this.fetchStream.bind(this)}\n          ref={forwardedRef}\n        />\n      );\n    }\n  }\n\n  const mapStateToProps = (state) => ({ settings: state.streaming.settings });\n  const WrapperComponent = hoistNonReactStatic(\n    connect(mapStateToProps)(WebRTCAdaptor),\n    WrappedComponent\n  );\n  WrapperComponent.displayName = 'WrapperComponent';\n  const ForwadedRefWapper = React.forwardRef<\n    {},\n    Omit<IProps & Partial<P>, 'settings'>\n  >((props, ref) => <WrapperComponent {...props} forwardedRef={ref} />);\n  ForwadedRefWapper.displayName = 'WebRTCAdaptor';\n  return ForwadedRefWapper;\n}\n"]},"metadata":{},"sourceType":"module"}