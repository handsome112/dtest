{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable camelcase */\nimport * as React from 'react';\nimport classnames from 'classnames';\nimport withAntMedia from 'src/antmedia';\nimport { streamService } from 'src/services';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from 'src/antmedia/constants';\nimport './index.less';\nimport videojs from 'video.js';\nimport Router from 'next/router';\nconst DEFAULT_IMAGE_URL = '/';\n\nclass Subscriber extends React.PureComponent {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"streamId\", void 0);\n\n    _defineProperty(this, \"onTrack\", void 0);\n\n    _defineProperty(this, \"player\", void 0);\n\n    _defineProperty(this, \"getLiveStreamOrVodURLInterval\", void 0);\n\n    _defineProperty(this, \"onbeforeunload\", () => {\n      this.destroyPlaybackVideo();\n    });\n\n    _defineProperty(this, \"ended\", async () => {\n      this.player && this.player.error(null);\n      const {\n        settings\n      } = this.props;\n\n      if (!this.streamId) {\n        this.resetPlaybackVideo();\n        return;\n      }\n\n      const src = await streamService.getLiveStreamOrVodURL({\n        streamId: this.streamId,\n        settings,\n        appName: settings.AntMediaAppname\n      });\n\n      if (src) {\n        this.getLiveStreamOrVodURLInterval = setInterval(() => {\n          fetch(src, {\n            method: 'HEAD'\n          }).then(() => {\n            this.playHLS(this.streamId);\n          });\n        }, 5000);\n      }\n    });\n  }\n\n  componentDidMount() {\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n  }\n\n  componentWillUnmount() {\n    Router.events.off('routeChangeStart', this.onbeforeunload);\n\n    if (this.getLiveStreamOrVodURLInterval) {\n      clearInterval(this.getLiveStreamOrVodURLInterval);\n      this.getLiveStreamOrVodURLInterval = null;\n    }\n  }\n\n  async handelWebRTCAdaptorCallback(info, obj) {\n    const {\n      webRTCAdaptor,\n      settings\n    } = this.props;\n\n    if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n      const token = await streamService.getSubscriberToken({\n        streamId: this.streamId,\n        settings\n      });\n      webRTCAdaptor.play(this.streamId, token);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.NEW_STREAM_AVAILABLE) {\n      if (this.onTrack === obj.streamId) {\n        return;\n      }\n\n      if (this.player) {\n        this.player.dispose();\n        this.player = null;\n      }\n\n      this.onTrack = obj.streamId;\n      this.createRemoteVideo(obj.stream);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_FINISHED) {\n      this.onTrack = null;\n      setTimeout(() => {\n        webRTCAdaptor.getStreamInfo(obj.streamId);\n      }, 5000);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.STREAM_INFORMATION) {\n      if (obj.streamId === this.streamId) {\n        const token = await streamService.getSubscriberToken({\n          streamId: obj.streamId,\n          settings\n        });\n        webRTCAdaptor.play(obj.streamId, token);\n      }\n    }\n  }\n\n  cbErrorHandler(error) {\n    if (error === 'no_stream_exist') {\n      const {\n        webRTCAdaptor,\n        initWebRTCAdaptor\n      } = this.props;\n\n      if (!webRTCAdaptor) {\n        initWebRTCAdaptor(this.handelWebRTCAdaptorCallback.bind(this), this.cbErrorHandler.bind(this));\n      } else {\n        this.streamId && webRTCAdaptor.getStreamInfo(this.streamId);\n      }\n    }\n  }\n\n  createPlaybackideo(poster = DEFAULT_IMAGE_URL) {\n    const {\n      classNames\n    } = this.props;\n    const video = document.createElement('video');\n    video.setAttribute('id', 'subscriber');\n    video.setAttribute('class', classnames('video-js broadcaster', classNames));\n    video.autoplay = true;\n    video.muted = true;\n    video.controls = true;\n    video.playsInline = true;\n    document.querySelector('.video-container').append(video);\n    const player = videojs('subscriber', {\n      autoplay: true,\n      liveui: true,\n      muted: true,\n      controls: true,\n      bigPlayButton: false,\n      poster\n    }, () => {\n      this.player = player;\n    });\n    player.on('ended', this.ended);\n    player.on('error', this.ended);\n  }\n\n  resetPlaybackVideo(poster = DEFAULT_IMAGE_URL) {\n    this.destroyPlaybackVideo();\n\n    if (this.getLiveStreamOrVodURLInterval) {\n      clearInterval(this.getLiveStreamOrVodURLInterval);\n      this.getLiveStreamOrVodURLInterval = null;\n    }\n\n    this.createPlaybackideo(poster);\n  }\n\n  destroyPlaybackVideo() {\n    this.streamId = null;\n    this.onTrack = null;\n\n    if (this.player) {\n      this.player.dispose();\n      this.player = null;\n    }\n  }\n\n  createRemoteVideo(stream) {\n    const {\n      classNames\n    } = this.props;\n    const video = document.createElement('video');\n    video.setAttribute('id', 'subscriber');\n    video.setAttribute('class', classnames('video-js broadcaster', classNames));\n    video.autoplay = true;\n    video.muted = true;\n    video.playsInline = true;\n    video.srcObject = stream;\n    document.querySelector('.video-container').append(video);\n    const player = videojs('subscriber', {\n      liveui: true,\n      autoplay: true,\n      controls: true\n    }, () => {\n      this.player = player;\n    });\n    player.on('error', () => {\n      player.error(null);\n    });\n    player.addClass('vjs-waiting');\n  }\n\n  async play(streamId) {\n    const {\n      initWebRTCAdaptor,\n      initialized,\n      webRTCAdaptor,\n      settings\n    } = this.props;\n    this.streamId = streamId;\n\n    if (initialized) {\n      const token = await streamService.getSubscriberToken({\n        streamId,\n        settings\n      });\n      webRTCAdaptor.play(streamId, token);\n      return;\n    }\n\n    initWebRTCAdaptor(this.handelWebRTCAdaptorCallback.bind(this), this.cbErrorHandler.bind(this));\n  }\n\n  async playHLS(streamId, streamHeight = 0) {\n    if (!streamId) {\n      return;\n    }\n\n    if (!this.player) {\n      this.createPlaybackideo();\n    }\n\n    if (this.getLiveStreamOrVodURLInterval) {\n      clearInterval(this.getLiveStreamOrVodURLInterval);\n      this.getLiveStreamOrVodURLInterval = null;\n    }\n\n    const {\n      configs,\n      settings\n    } = this.props;\n    const appName = configs.appName || settings.AntMediaAppname;\n    this.streamId = streamId;\n    const src = await streamService.getLiveStreamOrVodURL({\n      appName,\n      settings,\n      streamId\n    }, streamHeight);\n\n    if (!src) {\n      return;\n    }\n\n    setTimeout(() => {\n      if (!this.player) return;\n      this.player.addClass('vjs-waiting');\n      this.player.src({\n        type: 'application/x-mpegURL',\n        src\n      });\n      this.player.play();\n      this.player.controls(true);\n    }, 1 * 1000);\n  }\n\n  stop() {\n    this.resetPlaybackVideo();\n  }\n\n  poster(src) {\n    if (this.player) {\n      this.player.poster(src);\n    }\n  }\n\n  render() {\n    return __jsx(\"div\", {\n      className: \"video-container\"\n    });\n  }\n\n}\n\nexport default withAntMedia(Subscriber);","map":{"version":3,"sources":["E:/WorkStation/Moldova/DTEST/src/components/streaming/subscriber.tsx"],"names":["React","classnames","withAntMedia","streamService","WEBRTC_ADAPTOR_INFORMATIONS","videojs","Router","DEFAULT_IMAGE_URL","Subscriber","PureComponent","destroyPlaybackVideo","player","error","settings","props","streamId","resetPlaybackVideo","src","getLiveStreamOrVodURL","appName","AntMediaAppname","getLiveStreamOrVodURLInterval","setInterval","fetch","method","then","playHLS","componentDidMount","events","on","onbeforeunload","componentWillUnmount","off","clearInterval","handelWebRTCAdaptorCallback","info","obj","webRTCAdaptor","INITIALIZED","token","getSubscriberToken","play","NEW_STREAM_AVAILABLE","onTrack","dispose","createRemoteVideo","stream","PLAY_FINISHED","setTimeout","getStreamInfo","STREAM_INFORMATION","cbErrorHandler","initWebRTCAdaptor","bind","createPlaybackideo","poster","classNames","video","document","createElement","setAttribute","autoplay","muted","controls","playsInline","querySelector","append","liveui","bigPlayButton","ended","srcObject","addClass","initialized","streamHeight","configs","type","stop","render"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\nimport * as React from 'react';\nimport classnames from 'classnames';\nimport withAntMedia from 'src/antmedia';\nimport { streamService } from 'src/services';\nimport { StreamSettings } from 'src/interfaces';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from 'src/antmedia/constants';\nimport {\n  WebRTCAdaptorConfigs,\n  WebRTCAdaptorProps\n} from 'src/antmedia/interfaces';\nimport './index.less';\nimport videojs from 'video.js';\nimport Router from 'next/router';\n\ninterface IProps extends WebRTCAdaptorProps {\n  settings: StreamSettings;\n  configs: Partial<WebRTCAdaptorConfigs>;\n}\n\nconst DEFAULT_IMAGE_URL = '/';\n\nclass Subscriber extends React.PureComponent<IProps> {\n  private streamId: string;\n\n  private onTrack: string;\n\n  private player: videojs.Player;\n\n  private getLiveStreamOrVodURLInterval: NodeJS.Timeout;\n\n  componentDidMount() {\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n  }\n\n  componentWillUnmount() {\n    Router.events.off('routeChangeStart', this.onbeforeunload);\n    if (this.getLiveStreamOrVodURLInterval) {\n      clearInterval(this.getLiveStreamOrVodURLInterval);\n      this.getLiveStreamOrVodURLInterval = null;\n    }\n  }\n\n  onbeforeunload = () => {\n    this.destroyPlaybackVideo();\n  };\n\n  ended = async () => {\n    this.player && this.player.error(null);\n    const { settings } = this.props;\n    if (!this.streamId) {\n      this.resetPlaybackVideo();\n      return;\n    }\n\n    const src = await streamService.getLiveStreamOrVodURL({\n      streamId: this.streamId,\n      settings,\n      appName: settings.AntMediaAppname\n    });\n    if (src) {\n      this.getLiveStreamOrVodURLInterval = setInterval(() => {\n        fetch(src, { method: 'HEAD' }).then(() => {\n          this.playHLS(this.streamId);\n        });\n      }, 5000);\n    }\n  };\n\n  async handelWebRTCAdaptorCallback(\n    info: WEBRTC_ADAPTOR_INFORMATIONS,\n    obj: any\n  ) {\n    const { webRTCAdaptor, settings } = this.props;\n    if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n      const token = await streamService.getSubscriberToken({\n        streamId: this.streamId,\n        settings\n      });\n      webRTCAdaptor.play(this.streamId, token);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.NEW_STREAM_AVAILABLE) {\n      if (this.onTrack === obj.streamId) {\n        return;\n      }\n\n      if (this.player) {\n        this.player.dispose();\n        this.player = null;\n      }\n\n      this.onTrack = obj.streamId;\n      this.createRemoteVideo(obj.stream);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_FINISHED) {\n      this.onTrack = null;\n      setTimeout(() => {\n        webRTCAdaptor.getStreamInfo(obj.streamId);\n      }, 5000);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.STREAM_INFORMATION) {\n      if (obj.streamId === this.streamId) {\n        const token = await streamService.getSubscriberToken({\n          streamId: obj.streamId,\n          settings\n        });\n        webRTCAdaptor.play(obj.streamId, token);\n      }\n    }\n  }\n\n  cbErrorHandler(error: string) {\n    if (error === 'no_stream_exist') {\n      const { webRTCAdaptor, initWebRTCAdaptor } = this.props;\n      if (!webRTCAdaptor) {\n        initWebRTCAdaptor(\n          this.handelWebRTCAdaptorCallback.bind(this),\n          this.cbErrorHandler.bind(this)\n        );\n      } else {\n        this.streamId && webRTCAdaptor.getStreamInfo(this.streamId);\n      }\n    }\n  }\n\n  createPlaybackideo(poster = DEFAULT_IMAGE_URL) {\n    const { classNames } = this.props;\n    const video = document.createElement('video');\n    video.setAttribute('id', 'subscriber');\n    video.setAttribute('class', classnames('video-js broadcaster', classNames));\n    video.autoplay = true;\n    video.muted = true;\n    video.controls = true;\n    video.playsInline = true;\n    document.querySelector('.video-container').append(video);\n    const player = videojs(\n      'subscriber',\n      {\n        autoplay: true,\n        liveui: true,\n        muted: true,\n        controls: true,\n        bigPlayButton: false,\n        poster\n      },\n      () => {\n        this.player = player;\n      }\n    );\n    player.on('ended', this.ended);\n    player.on('error', this.ended);\n  }\n\n  resetPlaybackVideo(poster = DEFAULT_IMAGE_URL) {\n    this.destroyPlaybackVideo();\n    if (this.getLiveStreamOrVodURLInterval) {\n      clearInterval(this.getLiveStreamOrVodURLInterval);\n      this.getLiveStreamOrVodURLInterval = null;\n    }\n    this.createPlaybackideo(poster);\n  }\n\n  destroyPlaybackVideo() {\n    this.streamId = null;\n    this.onTrack = null;\n    if (this.player) {\n      this.player.dispose();\n      this.player = null;\n    }\n  }\n\n  createRemoteVideo(stream: any) {\n    const { classNames } = this.props;\n    const video = document.createElement('video');\n    video.setAttribute('id', 'subscriber');\n    video.setAttribute('class', classnames('video-js broadcaster', classNames));\n    video.autoplay = true;\n    video.muted = true;\n    video.playsInline = true;\n    video.srcObject = stream;\n    document.querySelector('.video-container').append(video);\n    const player = videojs('subscriber', {\n      liveui: true,\n      autoplay: true,\n      controls: true\n    }, () => {\n      this.player = player;\n    });\n    player.on('error', () => {\n      player.error(null);\n    });\n    player.addClass('vjs-waiting');\n  }\n\n  async play(streamId: string) {\n    const {\n      initWebRTCAdaptor, initialized, webRTCAdaptor, settings\n    } = this.props;\n    this.streamId = streamId;\n    if (initialized) {\n      const token = await streamService.getSubscriberToken({\n        streamId,\n        settings\n      });\n      webRTCAdaptor.play(streamId, token);\n      return;\n    }\n\n    initWebRTCAdaptor(\n      this.handelWebRTCAdaptorCallback.bind(this),\n      this.cbErrorHandler.bind(this)\n    );\n  }\n\n  async playHLS(streamId: string, streamHeight = 0) {\n    if (!streamId) {\n      return;\n    }\n\n    if (!this.player) {\n      this.createPlaybackideo();\n    }\n\n    if (this.getLiveStreamOrVodURLInterval) {\n      clearInterval(this.getLiveStreamOrVodURLInterval);\n      this.getLiveStreamOrVodURLInterval = null;\n    }\n\n    const { configs, settings } = this.props;\n    const appName = configs.appName || settings.AntMediaAppname;\n    this.streamId = streamId;\n    const src = await streamService.getLiveStreamOrVodURL(\n      {\n        appName,\n        settings,\n        streamId\n      },\n      streamHeight\n    );\n    if (!src) {\n      return;\n    }\n\n    setTimeout(() => {\n      if (!this.player) return;\n\n      this.player.addClass('vjs-waiting');\n      this.player.src({\n        type: 'application/x-mpegURL',\n        src\n      });\n      this.player.play();\n      this.player.controls(true);\n    }, 1 * 1000);\n  }\n\n  stop() {\n    this.resetPlaybackVideo();\n  }\n\n  poster(src: string) {\n    if (this.player) {\n      this.player.poster(src);\n    }\n  }\n\n  render() {\n    return <div className=\"video-container\" />;\n  }\n}\n\nexport default withAntMedia(Subscriber);\n"]},"metadata":{},"sourceType":"module"}