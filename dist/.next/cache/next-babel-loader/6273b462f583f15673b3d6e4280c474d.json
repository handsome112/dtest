{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable camelcase */\nimport React from 'react';\nimport Router from 'next/router';\nimport { connect } from 'react-redux';\nimport { SETTING_KEYS } from 'src/constants';\nimport { message as message_ } from 'antd';\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from './constants';\nexport default function withAntmedia(WrappedComponent) {\n  class WebRTCAdaptor extends React.Component {\n    static async getInitialProps(ctx) {\n      const pageProps = WrappedComponent.getInitialProps && (await WrappedComponent.getInitialProps(ctx)); // Return props.\n\n      return _objectSpread({}, pageProps);\n    }\n\n    constructor(props) {\n      super(props);\n\n      _defineProperty(this, \"webRTCAdaptor\", void 0);\n\n      _defineProperty(this, \"autoRepublishIntervalJob\", void 0);\n\n      _defineProperty(this, \"initWebRTCAdaptorCallback\", void 0);\n\n      _defineProperty(this, \"initWebRTCAdaptorCallbackError\", void 0);\n\n      _defineProperty(this, \"onbeforeunload\", () => {\n        this.leaveSession();\n      });\n\n      this.state = {\n        initialized: false,\n        publish_started: false,\n        onTrack: null,\n        streamResolutions: [],\n        availableDevices: []\n      };\n    }\n\n    componentDidMount() {\n      const {\n        initImmediately\n      } = this.props;\n      initImmediately && this.initWebRTCAdaptor();\n      Router.events.on('routeChangeStart', this.onbeforeunload); // window.addEventListener('beforeunload', this.onbeforeunload);\n    }\n\n    componentWillUnmount() {\n      Router.events.off('routeChangeStart', this.onbeforeunload); // window.removeEventListener('beforeunload', this.onbeforeunload);\n    }\n\n    getStreamInfo(streamId) {\n      this.webRTCAdaptor && this.webRTCAdaptor.getStreamInfo(streamId);\n    }\n\n    getLiveStreamOrVodURL() {}\n\n    forceStreamQuality(streamId, streamHeight = 0) {\n      this.webRTCAdaptor && this.webRTCAdaptor.forceStreamQuality(streamId, streamHeight);\n    }\n\n    leaveSession() {\n      const {\n        onTrack,\n        initialized\n      } = this.state;\n      const {\n        configs: {\n          isPlayMode\n        }\n      } = this.props;\n\n      if (this.autoRepublishIntervalJob) {\n        window.clearInterval(this.autoRepublishIntervalJob);\n        this.autoRepublishIntervalJob = null;\n      }\n\n      if (this.webRTCAdaptor) {\n        if (onTrack) {\n          this.webRTCAdaptor.stop(onTrack);\n          this.webRTCAdaptor.closePeerConnection(onTrack);\n        }\n\n        if (initialized) {\n          this.webRTCAdaptor.closeWebSocket();\n          !isPlayMode && this.webRTCAdaptor.closeStream();\n        }\n\n        this.webRTCAdaptor = null;\n      }\n\n      this.initWebRTCAdaptorCallback = null;\n      this.initWebRTCAdaptorCallbackError = null;\n      this.setState({\n        onTrack: null,\n        initialized: false,\n        streamResolutions: [],\n        availableDevices: []\n      });\n    }\n\n    initWebRTCAdaptor(cb, cbError) {\n      const {\n        configs,\n        settings,\n        autoRepublishDisabled,\n        onChange\n      } = this.props;\n      const {\n        isPlayMode\n      } = configs;\n      const publisherURL = isPlayMode ? settings[SETTING_KEYS.SUBSCRIBER_URL] : settings[SETTING_KEYS.PUBLISHER_URL];\n\n      if (!publisherURL) {\n        message_.error('Undefined WebsocketURL!');\n        return;\n      }\n\n      if (!this.webRTCAdaptor && autoRepublishDisabled) return;\n      const pc_config = {\n        iceServers: [{\n          urls: 'stun:stun.l.google.com:19302'\n        }]\n      };\n      const sdpConstraints = {\n        OfferToReceiveAudio: false,\n        OfferToReceiveVideo: false\n      };\n      const mediaConstraints = {\n        video: true,\n        audio: true\n      };\n      const appName = configs.appName || settings.AntMediaAppname;\n      const path = `${publisherURL}/${appName}/websocket`;\n      let websocketURL = `ws://${path}`;\n\n      if (window.location.protocol.startsWith('https')) {\n        websocketURL = `wss://${path}`;\n      }\n\n      this.initWebRTCAdaptorCallback = cb;\n      this.initWebRTCAdaptorCallbackError = cbError; // eslint-disable-next-line dot-notation\n\n      this.webRTCAdaptor = new window['WebRTCAdaptor'](_objectSpread({\n        websocket_url: websocketURL,\n        mediaConstraints,\n        debug: process.env.NEXT_PUBLIC_DEBUG,\n        peerconnection_config: pc_config,\n        sdp_constraints: sdpConstraints,\n        bandwidth: parseInt(process.env.NEXT_PUBLIC_MAX_VIDEO_BITRATE_KBPS, 10) || 900,\n        isPlayMode: false,\n        callback: (info, obj) => {\n          if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n            this.setState({\n              initialized: true\n            });\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_STARTED) {\n            if (obj.streamId) {\n              this.setState({\n                publish_started: true,\n                onTrack: obj.streamId\n              });\n\n              if (!this.autoRepublishIntervalJob && !autoRepublishDisabled) {\n                this.autoRepublishIntervalJob = setInterval(this.checkAndRepublishIfRequired.bind(this), 5000);\n              }\n\n              this.webRTCAdaptor && this.webRTCAdaptor.enableStats(obj.streamId);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_FINISHED) {\n            this.setState({\n              publish_started: false,\n              onTrack: null\n            });\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.REFRESH_CONNECTION) {\n            const {\n              publish_started\n            } = this.state;\n\n            if (publish_started && !autoRepublishDisabled) {\n              this.checkAndRepublishIfRequired();\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.ICE_CONNECTION_STATE_CHANGED) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log('iceConnectionState Changed: ', JSON.stringify(obj));\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.UPDATED_STATS) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log('Peer stats Changed: ', JSON.stringify(obj));\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.BITRATEMEASUREMENT) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log('Bitrate Measurement: ', JSON.stringify(obj));\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_STARTED) {\n            if (obj.streamId) {\n              this.webRTCAdaptor && this.webRTCAdaptor.enableStats(obj.streamId);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_FINISHED) {\n            this.setState({\n              streamResolutions: []\n            });\n\n            if (obj.streamId) {\n              this.webRTCAdaptor && this.webRTCAdaptor.disableStats(obj.streamId);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.CLOSED) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log(`Connection closed: ${JSON.stringify(obj)}`);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.AVAILABLE_DEVICES) {\n            this.setState({\n              availableDevices: obj\n            });\n          }\n\n          onChange && typeof onChange === 'function' && onChange(info, obj);\n          cb && typeof cb === 'function' && cb(info, obj);\n        },\n        callbackError: (error, message) => {\n          cbError && typeof cbError === 'function' && cbError(error, message);\n          this.callbackError(error, message);\n        }\n      }, configs));\n    }\n\n    checkAndRepublishIfRequired() {\n      try {\n        const {\n          onTrack\n        } = this.state;\n        if (!this.webRTCAdaptor || !onTrack) return;\n        const iceState = this.webRTCAdaptor.iceConnectionState(onTrack);\n\n        if (iceState == null || iceState === 'failed' || iceState === 'disconnected') {\n          // eslint-disable-next-line no-console\n          console.error('Publish has stopped and will try to re-publish');\n          this.webRTCAdaptor.stop(onTrack);\n          this.webRTCAdaptor.closePeerConnection(onTrack);\n          this.webRTCAdaptor.closeWebSocket();\n          this.initWebRTCAdaptor(this.initWebRTCAdaptorCallback, this.initWebRTCAdaptorCallbackError);\n        }\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.error('error republish', e);\n      }\n    }\n\n    callbackError(error, message) {\n      // some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError\n      // eslint-disable-next-line no-console\n      console.error(`error callback: ${JSON.stringify(error)}`);\n\n      if (typeof message === 'string') {\n        // eslint-disable-next-line no-console\n        console.error('error message:', message);\n        message_.error(message, 5);\n        return;\n      }\n\n      let errorMessage = JSON.stringify(error);\n\n      if (errorMessage.indexOf('noStreamNameSpecified') !== -1 || errorMessage.indexOf('no_stream_exist') !== -1 || errorMessage.indexOf('license_suspended_please_renew_license') !== -1 || errorMessage.indexOf('WebSocketNotConnected') !== -1) {\n        return;\n      }\n\n      if (errorMessage.indexOf('isTrusted') !== -1) {\n        this.leaveSession();\n        return;\n      }\n\n      if (errorMessage.indexOf('NotFoundError') !== -1) {\n        errorMessage = 'Camera or Mic are not found or not allowed in your device';\n      } else if (errorMessage.indexOf('NotReadableError') !== -1 || errorMessage.indexOf('TrackStartError') !== -1) {\n        errorMessage = 'Camera or Mic is being used by some other process that does not let read the devices';\n      } else if (errorMessage.indexOf('OverconstrainedError') !== -1 || errorMessage.indexOf('ConstraintNotSatisfiedError') !== -1) {\n        errorMessage = 'There is no device found that fits your video and audio constraints. You may change video and audio constraints';\n      } else if (errorMessage.indexOf('NotAllowedError') !== -1 || errorMessage.indexOf('PermissionDeniedError') !== -1) {\n        errorMessage = 'You are not allowed to access camera and mic.';\n      } else if (errorMessage.indexOf('TypeError') !== -1) {\n        errorMessage = 'Video/Audio is required';\n      } else if (errorMessage.indexOf('ScreenSharePermissionDenied') !== -1) {\n        errorMessage = 'You are not allowed to access screen share';\n      } else if (errorMessage.indexOf('unauthorized_access') !== -1) {\n        errorMessage = 'Access Denied. You don’t have permission to access';\n      } else if (errorMessage.indexOf('streamIdInUse') !== -1) {\n        errorMessage = 'Stream have been already published. Please close the previous connection.';\n      } else if (errorMessage.indexOf('publishTimeoutError') !== -1) {\n        errorMessage = 'WebRTC Publishing Timeout Error';\n        this.leaveSession();\n      } else if (errorMessage.indexOf('not_allowed_unregistered_streams') !== -1) {\n        errorMessage = 'Stream with an unregistered id is not allowed';\n      } else if (errorMessage.indexOf('UnsecureContext') !== -1) {\n        errorMessage = 'Fatal Error: Browser cannot access camera and mic because of unsecure context. Please install SSL and access via https';\n      } else if (errorMessage.indexOf('WebSocketNotSupported') !== -1) {\n        errorMessage = 'Fatal Error: WebSocket not supported in this browser';\n      } else if (errorMessage.indexOf('AudioAlreadyActive') !== -1) {\n        errorMessage = 'AudioAlreadyActive';\n      } else if (errorMessage.indexOf('stream_not_active_or_expired') !== -1) {\n        errorMessage = 'Stream is not active or expired';\n      } else if (errorMessage.indexOf('notSetRemoteDescription') !== -1) {\n        /*\n         * If getting codec incompatible or remote description error, should try to play HLS\n         */\n      } else if (errorMessage.indexOf('getUserMediaIsNotAllowed') !== -1) {\n        errorMessage = 'You are not allowed to reach devices from an insecure origin, please enable ssl';\n      } else {\n        errorMessage = 'Bad request!';\n      }\n\n      errorMessage && message_.error(errorMessage, 5);\n    }\n\n    muteLocalMic() {\n      if (this.webRTCAdaptor) {\n        this.webRTCAdaptor.muteLocalMic();\n      }\n    }\n\n    unmuteLocalMic() {\n      if (this.webRTCAdaptor) {\n        this.webRTCAdaptor.unmuteLocalMic();\n      }\n    }\n\n    startPublishing(idOfStream) {\n      if (this.webRTCAdaptor) {\n        this.webRTCAdaptor.publish(idOfStream, null);\n      }\n    }\n\n    stopPublishing() {\n      if (this.autoRepublishIntervalJob) {\n        window.clearInterval(this.autoRepublishIntervalJob);\n        this.autoRepublishIntervalJob = null;\n      }\n\n      const {\n        onTrack\n      } = this.state;\n      this.webRTCAdaptor && this.webRTCAdaptor.stop(onTrack);\n    }\n\n    fetchStream(streamId, token, extension = 'm3u8', cb) {\n      const {\n        settings\n      } = this.props;\n      const {\n        viewerURL,\n        AntMediaAppname: appName\n      } = settings;\n      let src = `${window.location.protocol}//${viewerURL}/${appName}/streams/${streamId}_adaptive.${extension}?token=${token}`;\n      fetch(src, {\n        method: 'HEAD'\n      }).then(response => {\n        if (response.status === 200) {\n          cb(null, src);\n        }\n\n        src = src.replace('_adaptive', '');\n        fetch(src, {\n          method: 'HEAD'\n        }) // eslint-disable-next-line no-shadow\n        .then(response => {\n          if (response.status === 200) {\n            cb(null, src);\n            return;\n          }\n\n          cb(response, null);\n        }).catch(err => {\n          cb(err, null);\n        });\n      }).catch(err => {\n        cb(err, null);\n      });\n    }\n\n    render() {\n      const {\n        forwardedRef\n      } = this.props;\n      return __jsx(WrappedComponent, _extends({}, this.props, this.state, {\n        webRTCAdaptor: this.webRTCAdaptor,\n        initWebRTCAdaptor: this.initWebRTCAdaptor.bind(this),\n        muteLocalMic: this.muteLocalMic.bind(this),\n        unmuteLocalMic: this.unmuteLocalMic.bind(this),\n        leaveSession: this.leaveSession.bind(this),\n        getStreamInfo: this.getStreamInfo.bind(this),\n        forceStreamQuality: this.forceStreamQuality.bind(this),\n        startPublishing: this.startPublishing.bind(this),\n        stopPublishing: this.stopPublishing.bind(this),\n        fetchStream: this.fetchStream.bind(this),\n        ref: forwardedRef\n      }));\n    }\n\n  }\n\n  const mapStateToProps = state => ({\n    settings: state.streaming.settings\n  });\n\n  const WrapperComponent = hoistNonReactStatic(connect(mapStateToProps)(WebRTCAdaptor), WrappedComponent);\n  WrapperComponent.displayName = 'WrapperComponent';\n  const ForwadedRefWapper = /*#__PURE__*/React.forwardRef((props, ref) => __jsx(WrapperComponent, _extends({}, props, {\n    forwardedRef: ref\n  })));\n  ForwadedRefWapper.displayName = 'WebRTCAdaptor';\n  return ForwadedRefWapper;\n}","map":{"version":3,"sources":["E:/WorkStation/Moldova/DTEST/src/antmedia/index.tsx"],"names":["React","Router","connect","SETTING_KEYS","message","message_","hoistNonReactStatic","WEBRTC_ADAPTOR_INFORMATIONS","withAntmedia","WrappedComponent","WebRTCAdaptor","Component","getInitialProps","ctx","pageProps","constructor","props","leaveSession","state","initialized","publish_started","onTrack","streamResolutions","availableDevices","componentDidMount","initImmediately","initWebRTCAdaptor","events","on","onbeforeunload","componentWillUnmount","off","getStreamInfo","streamId","webRTCAdaptor","getLiveStreamOrVodURL","forceStreamQuality","streamHeight","configs","isPlayMode","autoRepublishIntervalJob","window","clearInterval","stop","closePeerConnection","closeWebSocket","closeStream","initWebRTCAdaptorCallback","initWebRTCAdaptorCallbackError","setState","cb","cbError","settings","autoRepublishDisabled","onChange","publisherURL","SUBSCRIBER_URL","PUBLISHER_URL","error","pc_config","iceServers","urls","sdpConstraints","OfferToReceiveAudio","OfferToReceiveVideo","mediaConstraints","video","audio","appName","AntMediaAppname","path","websocketURL","location","protocol","startsWith","websocket_url","debug","process","env","NEXT_PUBLIC_DEBUG","peerconnection_config","sdp_constraints","bandwidth","parseInt","NEXT_PUBLIC_MAX_VIDEO_BITRATE_KBPS","callback","info","obj","INITIALIZED","PUBLISH_STARTED","setInterval","checkAndRepublishIfRequired","bind","enableStats","PUBLISH_FINISHED","REFRESH_CONNECTION","ICE_CONNECTION_STATE_CHANGED","console","log","JSON","stringify","UPDATED_STATS","BITRATEMEASUREMENT","PLAY_STARTED","PLAY_FINISHED","disableStats","CLOSED","AVAILABLE_DEVICES","callbackError","iceState","iceConnectionState","e","errorMessage","indexOf","muteLocalMic","unmuteLocalMic","startPublishing","idOfStream","publish","stopPublishing","fetchStream","token","extension","viewerURL","src","fetch","method","then","response","status","replace","catch","err","render","forwardedRef","mapStateToProps","streaming","WrapperComponent","displayName","ForwadedRefWapper","forwardRef","ref"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\nimport React from 'react';\nimport Router from 'next/router';\nimport { connect } from 'react-redux';\nimport { StreamSettings } from 'src/interfaces';\nimport { SETTING_KEYS } from 'src/constants';\nimport { message as message_ } from 'antd';\nimport { NextComponentType, NextPageContext } from 'next';\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from './constants';\nimport {\n  WebRTCAdaptorConfigs,\n  WebRTCAdaptorCallback,\n  WebRTCAdaptorCallbackError,\n  IWebRTCAdaptor,\n  WebRTCAdaptorProps,\n  Device\n} from './interfaces';\n\ninterface IProps {\n  configs: Partial<WebRTCAdaptorConfigs>;\n  settings: StreamSettings;\n  classNames?: string;\n  containerClassName?: string;\n  forwardedRef?: any;\n  initImmediately?: boolean;\n  autoRepublishDisabled?: boolean;\n  onClick?: any;\n  onChange?: WebRTCAdaptorCallback;\n}\n\ninterface IStates {\n  initialized: boolean;\n  publish_started: boolean;\n  streamResolutions: number[];\n  onTrack: string;\n  availableDevices: Device[];\n}\n\ntype WrappedComponentProps = React.ComponentProps<\n  React.ComponentClass<\n    Partial<IProps & WebRTCAdaptorProps & React.RefAttributes<any>>\n  >\n>;\n\nexport default function withAntmedia<P = any>(\n  WrappedComponent: NextComponentType<\n    NextPageContext,\n    any,\n    WrappedComponentProps\n  >\n) {\n  class WebRTCAdaptor extends React.Component<IProps, IStates> {\n    private webRTCAdaptor: IWebRTCAdaptor;\n\n    private autoRepublishIntervalJob: NodeJS.Timeout;\n\n    private initWebRTCAdaptorCallback: WebRTCAdaptorCallback;\n\n    private initWebRTCAdaptorCallbackError: WebRTCAdaptorCallbackError;\n\n    static async getInitialProps(ctx: NextPageContext) {\n      const pageProps = WrappedComponent.getInitialProps\n        && (await WrappedComponent.getInitialProps(ctx));\n      // Return props.\n      return { ...pageProps };\n    }\n\n    constructor(props: IProps) {\n      super(props);\n      this.state = {\n        initialized: false,\n        publish_started: false,\n        onTrack: null,\n        streamResolutions: [],\n        availableDevices: []\n      };\n    }\n\n    componentDidMount() {\n      const { initImmediately } = this.props;\n      initImmediately && this.initWebRTCAdaptor();\n      Router.events.on('routeChangeStart', this.onbeforeunload);\n      // window.addEventListener('beforeunload', this.onbeforeunload);\n    }\n\n    componentWillUnmount() {\n      Router.events.off('routeChangeStart', this.onbeforeunload);\n      // window.removeEventListener('beforeunload', this.onbeforeunload);\n    }\n\n    onbeforeunload = () => {\n      this.leaveSession();\n    };\n\n    getStreamInfo(streamId: string) {\n      this.webRTCAdaptor && this.webRTCAdaptor.getStreamInfo(streamId);\n    }\n\n    getLiveStreamOrVodURL() {}\n\n    forceStreamQuality(streamId: string, streamHeight = 0) {\n      this.webRTCAdaptor\n        && this.webRTCAdaptor.forceStreamQuality(streamId, streamHeight);\n    }\n\n    leaveSession() {\n      const { onTrack, initialized } = this.state;\n      const {\n        configs: { isPlayMode }\n      } = this.props;\n      if (this.autoRepublishIntervalJob) {\n        window.clearInterval(this.autoRepublishIntervalJob);\n        this.autoRepublishIntervalJob = null;\n      }\n\n      if (this.webRTCAdaptor) {\n        if (onTrack) {\n          this.webRTCAdaptor.stop(onTrack);\n          this.webRTCAdaptor.closePeerConnection(onTrack);\n        }\n        if (initialized) {\n          this.webRTCAdaptor.closeWebSocket();\n          !isPlayMode && this.webRTCAdaptor.closeStream();\n        }\n        this.webRTCAdaptor = null;\n      }\n\n      this.initWebRTCAdaptorCallback = null;\n      this.initWebRTCAdaptorCallbackError = null;\n      this.setState({\n        onTrack: null,\n        initialized: false,\n        streamResolutions: [],\n        availableDevices: []\n      });\n    }\n\n    initWebRTCAdaptor(\n      cb?: WebRTCAdaptorCallback,\n      cbError?: WebRTCAdaptorCallbackError\n    ) {\n      const {\n        configs, settings, autoRepublishDisabled, onChange\n      } = this.props;\n      const { isPlayMode } = configs;\n      const publisherURL = isPlayMode\n        ? settings[SETTING_KEYS.SUBSCRIBER_URL]\n        : settings[SETTING_KEYS.PUBLISHER_URL];\n      if (!publisherURL) {\n        message_.error('Undefined WebsocketURL!');\n        return;\n      }\n\n      if (!this.webRTCAdaptor && autoRepublishDisabled) return;\n\n      const pc_config = {\n        iceServers: [\n          {\n            urls: 'stun:stun.l.google.com:19302'\n          }\n        ]\n      };\n\n      const sdpConstraints = {\n        OfferToReceiveAudio: false,\n        OfferToReceiveVideo: false\n      };\n\n      const mediaConstraints = {\n        video: true,\n        audio: true\n      };\n\n      const appName = configs.appName || settings.AntMediaAppname;\n      const path = `${publisherURL}/${appName}/websocket`;\n\n      let websocketURL = `ws://${path}`;\n\n      if (window.location.protocol.startsWith('https')) {\n        websocketURL = `wss://${path}`;\n      }\n\n      this.initWebRTCAdaptorCallback = cb;\n      this.initWebRTCAdaptorCallbackError = cbError;\n      // eslint-disable-next-line dot-notation\n      this.webRTCAdaptor = new window['WebRTCAdaptor']({\n        websocket_url: websocketURL,\n        mediaConstraints,\n        debug: process.env.NEXT_PUBLIC_DEBUG,\n        peerconnection_config: pc_config,\n        sdp_constraints: sdpConstraints,\n        bandwidth: parseInt(process.env.NEXT_PUBLIC_MAX_VIDEO_BITRATE_KBPS, 10) || 900,\n        isPlayMode: false,\n        callback: (info: WEBRTC_ADAPTOR_INFORMATIONS, obj: any) => {\n          if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n            this.setState({ initialized: true });\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_STARTED) {\n            if (obj.streamId) {\n              this.setState({\n                publish_started: true,\n                onTrack: obj.streamId\n              });\n              if (!this.autoRepublishIntervalJob && !autoRepublishDisabled) {\n                this.autoRepublishIntervalJob = setInterval(\n                  this.checkAndRepublishIfRequired.bind(this),\n                  5000\n                );\n              }\n              this.webRTCAdaptor && this.webRTCAdaptor.enableStats(obj.streamId);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PUBLISH_FINISHED) {\n            this.setState({ publish_started: false, onTrack: null });\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.REFRESH_CONNECTION) {\n            const { publish_started } = this.state;\n            if (publish_started && !autoRepublishDisabled) {\n              this.checkAndRepublishIfRequired();\n            }\n          } else if (\n            info === WEBRTC_ADAPTOR_INFORMATIONS.ICE_CONNECTION_STATE_CHANGED\n          ) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log('iceConnectionState Changed: ', JSON.stringify(obj));\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.UPDATED_STATS) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log('Peer stats Changed: ', JSON.stringify(obj));\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.BITRATEMEASUREMENT) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log('Bitrate Measurement: ', JSON.stringify(obj));\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_STARTED) {\n            if (obj.streamId) {\n              this.webRTCAdaptor && this.webRTCAdaptor.enableStats(obj.streamId);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_FINISHED) {\n            this.setState({ streamResolutions: [] });\n            if (obj.streamId) {\n              this.webRTCAdaptor && this.webRTCAdaptor.disableStats(obj.streamId);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.CLOSED) {\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log(`Connection closed: ${JSON.stringify(obj)}`);\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.AVAILABLE_DEVICES) {\n            this.setState({ availableDevices: obj });\n          }\n\n          onChange && typeof onChange === 'function' && onChange(info, obj);\n          cb && typeof cb === 'function' && cb(info, obj);\n        },\n        callbackError: (error, message) => {\n          cbError && typeof cbError === 'function' && cbError(error, message);\n          this.callbackError(error, message);\n        },\n        ...configs\n      });\n    }\n\n    checkAndRepublishIfRequired() {\n      try {\n        const { onTrack } = this.state;\n        if (!this.webRTCAdaptor || !onTrack) return;\n\n        const iceState = this.webRTCAdaptor.iceConnectionState(onTrack);\n        if (\n          iceState == null\n          || iceState === 'failed'\n          || iceState === 'disconnected'\n        ) {\n          // eslint-disable-next-line no-console\n          console.error('Publish has stopped and will try to re-publish');\n          this.webRTCAdaptor.stop(onTrack);\n          this.webRTCAdaptor.closePeerConnection(onTrack);\n          this.webRTCAdaptor.closeWebSocket();\n          this.initWebRTCAdaptor(\n            this.initWebRTCAdaptorCallback,\n            this.initWebRTCAdaptorCallbackError\n          );\n        }\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.error('error republish', e);\n      }\n    }\n\n    callbackError(error, message) {\n      // some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError\n      // eslint-disable-next-line no-console\n      console.error(`error callback: ${JSON.stringify(error)}`);\n      if (typeof message === 'string') {\n        // eslint-disable-next-line no-console\n        console.error('error message:', message);\n        message_.error(message, 5);\n        return;\n      }\n\n      let errorMessage = JSON.stringify(error);\n      if (\n        errorMessage.indexOf('noStreamNameSpecified') !== -1\n        || errorMessage.indexOf('no_stream_exist') !== -1\n        || errorMessage.indexOf('license_suspended_please_renew_license') !== -1\n        || errorMessage.indexOf('WebSocketNotConnected') !== -1\n      ) {\n        return;\n      }\n\n      if (errorMessage.indexOf('isTrusted') !== -1) {\n        this.leaveSession();\n        return;\n      }\n\n      if (errorMessage.indexOf('NotFoundError') !== -1) {\n        errorMessage = 'Camera or Mic are not found or not allowed in your device';\n      } else if (\n        errorMessage.indexOf('NotReadableError') !== -1\n        || errorMessage.indexOf('TrackStartError') !== -1\n      ) {\n        errorMessage = 'Camera or Mic is being used by some other process that does not let read the devices';\n      } else if (\n        errorMessage.indexOf('OverconstrainedError') !== -1\n        || errorMessage.indexOf('ConstraintNotSatisfiedError') !== -1\n      ) {\n        errorMessage = 'There is no device found that fits your video and audio constraints. You may change video and audio constraints';\n      } else if (\n        errorMessage.indexOf('NotAllowedError') !== -1\n        || errorMessage.indexOf('PermissionDeniedError') !== -1\n      ) {\n        errorMessage = 'You are not allowed to access camera and mic.';\n      } else if (errorMessage.indexOf('TypeError') !== -1) {\n        errorMessage = 'Video/Audio is required';\n      } else if (errorMessage.indexOf('ScreenSharePermissionDenied') !== -1) {\n        errorMessage = 'You are not allowed to access screen share';\n      } else if (errorMessage.indexOf('unauthorized_access') !== -1) {\n        errorMessage = 'Access Denied. You don’t have permission to access';\n      } else if (errorMessage.indexOf('streamIdInUse') !== -1) {\n        errorMessage = 'Stream have been already published. Please close the previous connection.';\n      } else if (errorMessage.indexOf('publishTimeoutError') !== -1) {\n        errorMessage = 'WebRTC Publishing Timeout Error';\n        this.leaveSession();\n      } else if (\n        errorMessage.indexOf('not_allowed_unregistered_streams') !== -1\n      ) {\n        errorMessage = 'Stream with an unregistered id is not allowed';\n      } else if (errorMessage.indexOf('UnsecureContext') !== -1) {\n        errorMessage = 'Fatal Error: Browser cannot access camera and mic because of unsecure context. Please install SSL and access via https';\n      } else if (errorMessage.indexOf('WebSocketNotSupported') !== -1) {\n        errorMessage = 'Fatal Error: WebSocket not supported in this browser';\n      } else if (errorMessage.indexOf('AudioAlreadyActive') !== -1) {\n        errorMessage = 'AudioAlreadyActive';\n      } else if (errorMessage.indexOf('stream_not_active_or_expired') !== -1) {\n        errorMessage = 'Stream is not active or expired';\n      } else if (errorMessage.indexOf('notSetRemoteDescription') !== -1) {\n        /*\n         * If getting codec incompatible or remote description error, should try to play HLS\n         */\n      } else if (errorMessage.indexOf('getUserMediaIsNotAllowed') !== -1) {\n        errorMessage = 'You are not allowed to reach devices from an insecure origin, please enable ssl';\n      } else {\n        errorMessage = 'Bad request!';\n      }\n\n      errorMessage && message_.error(errorMessage, 5);\n    }\n\n    muteLocalMic() {\n      if (this.webRTCAdaptor) {\n        this.webRTCAdaptor.muteLocalMic();\n      }\n    }\n\n    unmuteLocalMic() {\n      if (this.webRTCAdaptor) {\n        this.webRTCAdaptor.unmuteLocalMic();\n      }\n    }\n\n    startPublishing(idOfStream: string) {\n      if (this.webRTCAdaptor) {\n        this.webRTCAdaptor.publish(idOfStream, null);\n      }\n    }\n\n    stopPublishing() {\n      if (this.autoRepublishIntervalJob) {\n        window.clearInterval(this.autoRepublishIntervalJob);\n        this.autoRepublishIntervalJob = null;\n      }\n\n      const { onTrack } = this.state;\n      this.webRTCAdaptor && this.webRTCAdaptor.stop(onTrack);\n    }\n\n    fetchStream(\n      streamId: string,\n      token: string,\n      extension = 'm3u8',\n      cb: (error: any, src: string) => void\n    ) {\n      const { settings } = this.props;\n      const { viewerURL, AntMediaAppname: appName } = settings;\n      let src = `${window.location.protocol}//${viewerURL}/${appName}/streams/${streamId}_adaptive.${extension}?token=${token}`;\n      fetch(src, { method: 'HEAD' })\n        .then((response) => {\n          if (response.status === 200) {\n            cb(null, src);\n          }\n\n          src = src.replace('_adaptive', '');\n          fetch(src, { method: 'HEAD' })\n            // eslint-disable-next-line no-shadow\n            .then((response) => {\n              if (response.status === 200) {\n                cb(null, src);\n                return;\n              }\n\n              cb(response, null);\n            })\n            .catch((err) => {\n              cb(err, null);\n            });\n        })\n        .catch((err) => {\n          cb(err, null);\n        });\n    }\n\n    render() {\n      const { forwardedRef } = this.props;\n      return (\n        <WrappedComponent\n          {...this.props}\n          {...this.state}\n          webRTCAdaptor={this.webRTCAdaptor}\n          initWebRTCAdaptor={this.initWebRTCAdaptor.bind(this)}\n          muteLocalMic={this.muteLocalMic.bind(this)}\n          unmuteLocalMic={this.unmuteLocalMic.bind(this)}\n          leaveSession={this.leaveSession.bind(this)}\n          getStreamInfo={this.getStreamInfo.bind(this)}\n          forceStreamQuality={this.forceStreamQuality.bind(this)}\n          startPublishing={this.startPublishing.bind(this)}\n          stopPublishing={this.stopPublishing.bind(this)}\n          fetchStream={this.fetchStream.bind(this)}\n          ref={forwardedRef}\n        />\n      );\n    }\n  }\n\n  const mapStateToProps = (state) => ({ settings: state.streaming.settings });\n  const WrapperComponent = hoistNonReactStatic(\n    connect(mapStateToProps)(WebRTCAdaptor),\n    WrappedComponent\n  );\n  WrapperComponent.displayName = 'WrapperComponent';\n  const ForwadedRefWapper = React.forwardRef<\n    {},\n    Omit<IProps & Partial<P>, 'settings'>\n  >((props, ref) => <WrapperComponent {...props} forwardedRef={ref} />);\n  ForwadedRefWapper.displayName = 'WebRTCAdaptor';\n  return ForwadedRefWapper;\n}\n"]},"metadata":{},"sourceType":"module"}