{"ast":null,"code":"/* eslint-disable no-console */\nimport { flatten } from 'lodash';\nimport { put, select } from 'redux-saga/effects';\nimport { createSagas } from '@lib/redux';\nimport { messageService } from '@services/message.service';\nimport { message } from 'antd';\nimport { getStreamConversation, getStreamConversationSuccess, fetchingStreamMessage, loadMoreStreamMessages, loadMoreStreamMessagesSuccess, loadStreamMessages, loadStreamMessagesSuccess, sendStreamMessage, sendStreamMessageSuccess, deleteMessage, deleteMessageSuccess } from './actions';\nconst streamMessageSagas = [{\n  on: getStreamConversation,\n\n  *worker(data) {\n    try {\n      const {\n        conversation\n      } = data.payload;\n      const {\n        type\n      } = conversation;\n      const resp = type === 'stream_public' ? yield messageService.findPublicConversationPerformer(conversation.performerId) : yield messageService.getConversationByStreamId(conversation.streamId);\n\n      if (resp && resp.data) {\n        yield put(getStreamConversationSuccess({\n          data: resp.data\n        }));\n        yield put(loadStreamMessages({\n          conversationId: resp.data._id,\n          limit: 25,\n          offset: 0,\n          type\n        }));\n      }\n    } catch (e) {\n      // load error\n      console.log('err-get-conversation', e);\n    }\n  }\n\n}, {\n  on: loadStreamMessages,\n\n  *worker(data) {\n    try {\n      const {\n        conversationId,\n        offset,\n        limit,\n        type\n      } = data.payload;\n      yield put(fetchingStreamMessage({\n        conversationId\n      }));\n      const resp = type === 'stream_public' ? yield messageService.getPublicMessages(conversationId, {\n        sort: 'desc',\n        offset,\n        limit\n      }) : yield messageService.getMessages(conversationId, {\n        sort: 'desc',\n        offset,\n        limit\n      });\n      yield put(loadStreamMessagesSuccess({\n        conversationId,\n        items: resp.data.data,\n        total: resp.data.total\n      }));\n    } catch (e) {\n      // load error\n      console.log('err', e);\n    }\n  }\n\n}, {\n  on: loadMoreStreamMessages,\n\n  *worker(data) {\n    try {\n      const messageMap = select(state => state.streamMessage.messages);\n      const {\n        conversationId,\n        offset,\n        limit,\n        type\n      } = data.payload;\n\n      if (messageMap && messageMap.fetching) {\n        return;\n      }\n\n      yield put(fetchingStreamMessage({\n        conversationId\n      }));\n      const resp = type === 'stream_public' ? yield messageService.getPublicMessages(conversationId, {\n        sort: 'desc',\n        offset,\n        limit\n      }) : yield messageService.getMessages(conversationId, {\n        sort: 'desc',\n        offset,\n        limit\n      });\n      yield put(loadMoreStreamMessagesSuccess({\n        conversationId,\n        items: resp.data.data,\n        total: resp.data.total\n      }));\n    } catch (e) {\n      // load error\n      message.error('Error occured, please try again later');\n      console.log('err', e);\n    }\n  }\n\n}, {\n  on: sendStreamMessage,\n\n  *worker(req) {\n    try {\n      const {\n        conversationId,\n        data,\n        type\n      } = req.payload;\n      const resp = type === 'stream_public' ? yield messageService.sendPublicStreamMessage(conversationId, data) : yield messageService.sendStreamMessage(conversationId, data);\n      yield put(sendStreamMessageSuccess(resp.data));\n    } catch (e) {\n      yield put(sendStreamMessageSuccess(e));\n    }\n  }\n\n}, {\n  on: deleteMessage,\n\n  *worker(req) {\n    try {\n      const {\n        messageId\n      } = req.payload;\n      const resp = yield messageService.deleteMessage(messageId);\n      yield put(deleteMessageSuccess(resp.data));\n    } catch (e) {\n      yield put(deleteMessageSuccess(e));\n    }\n  }\n\n}];\nexport default flatten([createSagas(streamMessageSagas)]);","map":null,"metadata":{},"sourceType":"module"}