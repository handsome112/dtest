{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { flatten, omit } from 'lodash';\nimport { put, select, all } from 'redux-saga/effects';\nimport { createSagas } from '@lib/redux';\nimport { earningService, studioService, payoutRequestService } from '@services/index';\nimport { updateStudio, updateStudioSuccess, updateStudioFail, setUpdatingStudio, updateStudioPaymentInfo, updateStudioDirectDeposit, updateStudioBitpay, updateStudioPaxum, getMembers, getMembersSuccess, getMembersFail, getMembersSearching, getMembersCommissions, getMembersCommissionsSuccess, getMembersCommissionsFail, getMembersCommissionsSearching, getStudioEarning, getStudioEarningFail, getStudioEarningSuccess, setGettingStudioEarning, getStudioPayoutRequest, getStudioPayoutRequestFail, getStudioPayoutRequestSuccess, setGettingStudioPayoutRequest, getPerformerRequest, getPerformerRequestFail, getPerformerRequestSuccess, setGettingPerformerRequest, getStudioStats, getStudioStatsSuccess, getStudioStatsFail } from './actions';\nconst studioSagas = [{\n  on: updateStudio,\n\n  *worker(data) {\n    try {\n      yield put(setUpdatingStudio());\n      const updated = yield studioService.update(data.payload);\n      yield put(updateStudioSuccess(updated.data));\n    } catch (e) {\n      const err = yield Promise.resolve(e);\n      yield put(updateStudioFail(err));\n    }\n  }\n\n}, {\n  on: updateStudioPaymentInfo,\n\n  *worker(action) {\n    try {\n      yield put(setUpdatingStudio());\n      const resp = yield studioService.updatePaymentInfo(action.payload);\n      yield put(updateStudioSuccess(resp.data));\n    } catch (e) {\n      const err = yield Promise.resolve(e);\n      yield put(updateStudioFail(err));\n    }\n  }\n\n}, {\n  on: updateStudioDirectDeposit,\n\n  *worker(action) {\n    try {\n      yield put(setUpdatingStudio());\n      const resp = yield studioService.updateDirectDepost(action.payload);\n      yield put(updateStudioSuccess(resp.data));\n    } catch (e) {\n      const err = yield Promise.resolve(e);\n      yield put(updateStudioFail(err));\n    }\n  }\n\n}, {\n  on: updateStudioBitpay,\n\n  *worker(action) {\n    try {\n      yield put(setUpdatingStudio());\n      const resp = yield studioService.updateBitpay(action.payload);\n      yield put(updateStudioSuccess(resp.data));\n    } catch (e) {\n      const err = yield Promise.resolve(e);\n      yield put(updateStudioFail(err));\n    }\n  }\n\n}, {\n  on: updateStudioPaxum,\n\n  *worker(action) {\n    try {\n      yield put(setUpdatingStudio());\n      const resp = yield studioService.updatePaxum(action.payload);\n      yield put(updateStudioSuccess(resp.data));\n    } catch (e) {\n      const err = yield Promise.resolve(e);\n      yield put(updateStudioFail(err));\n    }\n  }\n\n}, {\n  on: getMembers,\n\n  *worker(action) {\n    try {\n      yield put(getMembersSearching());\n      const resp = yield studioService.getMembers(action.payload);\n      yield put(getMembersSuccess(resp.data));\n    } catch (e) {\n      const err = yield Promise.resolve(e);\n      yield put(getMembersFail(err));\n    }\n  }\n\n}, {\n  on: getMembersCommissions,\n\n  *worker(action) {\n    try {\n      yield put(getMembersCommissionsSearching());\n      const resp = yield studioService.getMemberCommissions(action.payload);\n      yield put(getMembersCommissionsSuccess(resp.data));\n    } catch (e) {\n      const err = yield Promise.resolve(e);\n      yield put(getMembersCommissionsFail(err));\n    }\n  }\n\n}, {\n  on: getPerformerRequest,\n\n  *worker(action) {\n    try {\n      yield put(setGettingPerformerRequest());\n      const resp = yield studioService.getPerformerRequest(action.payload);\n      yield put(getPerformerRequestSuccess(resp.data));\n    } catch (e) {\n      const err = yield Promise.resolve(e);\n      yield put(getPerformerRequestFail(err));\n    }\n  }\n\n}, {\n  on: getStudioEarning,\n\n  *worker(action) {\n    try {\n      yield put(setGettingStudioEarning());\n      let difDateQuery = false;\n      const earning = yield select(state => state.performer.earning);\n      const {\n        fromDate,\n        toDate\n      } = action.payload;\n      const query = omit(action.payload, ['fromDate', 'toDate']);\n\n      if (fromDate && toDate) {\n        query.fromDate = fromDate;\n        query.toDate = toDate;\n      }\n\n      if (earning.toDate !== toDate || earning.fromDate !== fromDate) difDateQuery = true;\n      const [resp, stats] = yield all([earningService.search(query, 'studio'), earning.stats && !difDateQuery ? earning.stats : earningService.stats(query, 'studio')]);\n      yield put(getStudioEarningSuccess(_objectSpread(_objectSpread({}, query), {}, {\n        stats,\n        data: resp.data\n      })));\n    } catch (e) {\n      const err = yield Promise.resolve(e);\n      yield put(getStudioEarningFail(err));\n    }\n  }\n\n}, {\n  on: getStudioStats,\n\n  *worker() {\n    try {\n      const resp = yield studioService.stats();\n      yield put(getStudioStatsSuccess(resp.data));\n    } catch (e) {\n      const err = yield Promise.resolve(e);\n      yield put(getStudioStatsFail(err));\n    }\n  }\n\n}, {\n  on: getStudioPayoutRequest,\n\n  *worker(action) {\n    try {\n      yield put(setGettingStudioPayoutRequest());\n      const resp = yield payoutRequestService.studioSearch(action.payload);\n      yield put(getStudioPayoutRequestSuccess(resp.data));\n    } catch (e) {\n      const err = yield Promise.resolve(e);\n      yield put(getStudioPayoutRequestFail(err));\n    }\n  }\n\n}];\nexport default flatten([createSagas(studioSagas)]);","map":null,"metadata":{},"sourceType":"module"}