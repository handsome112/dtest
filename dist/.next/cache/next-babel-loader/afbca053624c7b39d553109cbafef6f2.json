{"ast":null,"code":"var _jsxFileName = \"/var/www/dtest.live/src/components/streaming/subscriber.tsx\";\nvar __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable camelcase */\nimport * as React from 'react';\nimport classnames from 'classnames';\nimport withAntMedia from 'src/antmedia';\nimport { streamService } from 'src/services';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from 'src/antmedia/constants';\nimport './index.less';\nimport videojs from 'video.js';\nimport Router from 'next/router';\nconst DEFAULT_IMAGE_URL = '/';\n\nclass Subscriber extends React.PureComponent {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"streamId\", void 0);\n\n    _defineProperty(this, \"onTrack\", void 0);\n\n    _defineProperty(this, \"player\", void 0);\n\n    _defineProperty(this, \"getLiveStreamOrVodURLInterval\", void 0);\n\n    _defineProperty(this, \"onbeforeunload\", () => {\n      this.destroyPlaybackVideo();\n    });\n\n    _defineProperty(this, \"ended\", async () => {\n      this.player && this.player.error(null);\n      const {\n        settings\n      } = this.props;\n\n      if (!this.streamId) {\n        this.resetPlaybackVideo();\n        return;\n      }\n\n      const src = await streamService.getLiveStreamOrVodURL({\n        streamId: this.streamId,\n        settings,\n        appName: settings.AntMediaAppname\n      });\n\n      if (src) {\n        this.getLiveStreamOrVodURLInterval = setInterval(() => {\n          fetch(src, {\n            method: 'HEAD'\n          }).then(() => {\n            this.playHLS(this.streamId);\n          });\n        }, 5000);\n      }\n    });\n  }\n\n  componentDidMount() {\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n  }\n\n  componentWillUnmount() {\n    Router.events.off('routeChangeStart', this.onbeforeunload);\n\n    if (this.getLiveStreamOrVodURLInterval) {\n      clearInterval(this.getLiveStreamOrVodURLInterval);\n      this.getLiveStreamOrVodURLInterval = null;\n    }\n  }\n\n  async handelWebRTCAdaptorCallback(info, obj) {\n    const {\n      webRTCAdaptor,\n      settings\n    } = this.props;\n\n    if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n      const token = await streamService.getSubscriberToken({\n        streamId: this.streamId,\n        settings\n      });\n      webRTCAdaptor.play(this.streamId, token);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.NEW_STREAM_AVAILABLE) {\n      if (this.onTrack === obj.streamId) {\n        return;\n      }\n\n      if (this.player) {\n        this.player.dispose();\n        this.player = null;\n      }\n\n      this.onTrack = obj.streamId;\n      this.createRemoteVideo(obj.stream);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_FINISHED) {\n      this.onTrack = null;\n      setTimeout(() => {\n        webRTCAdaptor.getStreamInfo(obj.streamId);\n      }, 5000);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.STREAM_INFORMATION) {\n      if (obj.streamId === this.streamId) {\n        const token = await streamService.getSubscriberToken({\n          streamId: obj.streamId,\n          settings\n        });\n        webRTCAdaptor.play(obj.streamId, token);\n      }\n    }\n  }\n\n  cbErrorHandler(error) {\n    if (error === 'no_stream_exist') {\n      const {\n        webRTCAdaptor,\n        initWebRTCAdaptor\n      } = this.props;\n\n      if (!webRTCAdaptor) {\n        initWebRTCAdaptor(this.handelWebRTCAdaptorCallback.bind(this), this.cbErrorHandler.bind(this));\n      } else {\n        this.streamId && webRTCAdaptor.getStreamInfo(this.streamId);\n      }\n    }\n  }\n\n  createPlaybackideo(poster = DEFAULT_IMAGE_URL) {\n    const {\n      classNames\n    } = this.props;\n    const video = document.createElement('video');\n    video.setAttribute('id', 'subscriber');\n    video.setAttribute('class', classnames('video-js broadcaster', classNames));\n    video.autoplay = true;\n    video.muted = true;\n    video.controls = true;\n    video.playsInline = true;\n    document.querySelector('.video-container').append(video);\n    const player = videojs('subscriber', {\n      autoplay: true,\n      liveui: true,\n      muted: true,\n      controls: true,\n      bigPlayButton: false,\n      poster\n    }, () => {\n      this.player = player;\n    });\n    player.on('ended', this.ended);\n    player.on('error', this.ended);\n  }\n\n  resetPlaybackVideo(poster = DEFAULT_IMAGE_URL) {\n    this.destroyPlaybackVideo();\n\n    if (this.getLiveStreamOrVodURLInterval) {\n      clearInterval(this.getLiveStreamOrVodURLInterval);\n      this.getLiveStreamOrVodURLInterval = null;\n    }\n\n    this.createPlaybackideo(poster);\n  }\n\n  destroyPlaybackVideo() {\n    this.streamId = null;\n    this.onTrack = null;\n\n    if (this.player) {\n      this.player.dispose();\n      this.player = null;\n    }\n  }\n\n  createRemoteVideo(stream) {\n    const {\n      classNames\n    } = this.props;\n    const video = document.createElement('video');\n    video.setAttribute('id', 'subscriber');\n    video.setAttribute('class', classnames('video-js broadcaster', classNames));\n    video.autoplay = true;\n    video.muted = true;\n    video.playsInline = true;\n    video.srcObject = stream;\n    document.querySelector('.video-container').append(video);\n    const player = videojs('subscriber', {\n      liveui: true,\n      autoplay: true,\n      controls: true\n    }, () => {\n      this.player = player;\n    });\n    player.on('error', () => {\n      player.error(null);\n    });\n    player.addClass('vjs-waiting');\n  }\n\n  async play(streamId) {\n    const {\n      initWebRTCAdaptor,\n      initialized,\n      webRTCAdaptor,\n      settings\n    } = this.props;\n    this.streamId = streamId;\n\n    if (initialized) {\n      const token = await streamService.getSubscriberToken({\n        streamId,\n        settings\n      });\n      webRTCAdaptor.play(streamId, token);\n      return;\n    }\n\n    initWebRTCAdaptor(this.handelWebRTCAdaptorCallback.bind(this), this.cbErrorHandler.bind(this));\n  }\n\n  async playHLS(streamId, streamHeight = 0) {\n    if (!streamId) {\n      return;\n    }\n\n    if (!this.player) {\n      this.createPlaybackideo();\n    }\n\n    if (this.getLiveStreamOrVodURLInterval) {\n      clearInterval(this.getLiveStreamOrVodURLInterval);\n      this.getLiveStreamOrVodURLInterval = null;\n    }\n\n    const {\n      configs,\n      settings\n    } = this.props;\n    const appName = configs.appName || settings.AntMediaAppname;\n    this.streamId = streamId;\n    const src = await streamService.getLiveStreamOrVodURL({\n      appName,\n      settings,\n      streamId\n    }, streamHeight);\n\n    if (!src) {\n      return;\n    }\n\n    setTimeout(() => {\n      if (!this.player) return;\n      this.player.addClass('vjs-waiting');\n      this.player.src({\n        type: 'application/x-mpegURL',\n        src\n      });\n      this.player.play();\n      this.player.controls(true);\n    }, 1 * 1000);\n  }\n\n  stop() {\n    this.resetPlaybackVideo();\n  }\n\n  poster(src) {\n    if (this.player) {\n      this.player.poster(src);\n    }\n  }\n\n  render() {\n    return __jsx(\"div\", {\n      className: \"video-container\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 265,\n        columnNumber: 12\n      }\n    });\n  }\n\n}\n\nexport default withAntMedia(Subscriber);","map":null,"metadata":{},"sourceType":"module"}