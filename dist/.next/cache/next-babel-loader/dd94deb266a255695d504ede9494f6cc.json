{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/* eslint-disable no-nested-ternary */\nimport React, { PureComponent, createRef } from 'react';\nimport { connect } from 'react-redux';\nimport moment from 'moment';\nimport Link from 'next/link';\nimport './MessageList.less';\nimport { loadMoreStreamMessages, receiveStreamMessageSuccess, resetStreamMessage, deleteMessage, deleteMessageSuccess } from '@redux/stream-chat/actions';\nimport { SocketContext } from 'src/socket';\nimport Router from 'next/router';\nimport Compose from './Compose';\nimport Message from './Message';\n\nvar MessageList = /*#__PURE__*/function (_PureComponent) {\n  _inherits(MessageList, _PureComponent);\n\n  var _super = _createSuper(MessageList);\n\n  function MessageList() {\n    var _this;\n\n    _classCallCheck(this, MessageList);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"messagesRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      page: 1,\n      onloadmore: false\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onbeforeunload\", function () {\n      var _this$props = _this.props,\n          conversation = _this$props.conversation,\n          dispatchResetStreamMessage = _this$props.resetStreamMessage;\n\n      if (conversation && conversation._id) {\n        dispatchResetStreamMessage();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onMessage\", function (message, type) {\n      var _this$props2 = _this.props,\n          dispatchReceiveStreamMessageSuccess = _this$props2.receiveStreamMessageSuccess,\n          dispatchDeleteMessageSuccess = _this$props2.deleteMessageSuccess;\n\n      if (!message) {\n        return;\n      }\n\n      type === 'created' && dispatchReceiveStreamMessageSuccess(message);\n      type === 'deleted' && dispatchDeleteMessageSuccess(message);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onDelete\", function (messageId) {\n      var dispatchDeleteMessage = _this.props.deleteMessage;\n      if (!messageId) return;\n      dispatchDeleteMessage({\n        messageId: messageId\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"renderMessages\", function () {\n      var _this$props3 = _this.props,\n          message = _this$props3.message,\n          currentUser = _this$props3.currentUser,\n          currentPerformer = _this$props3.currentPerformer,\n          conversation = _this$props3.conversation,\n          loggedIn = _this$props3.loggedIn;\n      var messages = message.items;\n      var fetching = message.fetching;\n      var i = 0;\n      var messageCount = messages && messages.length;\n\n      if (!messages.length && !fetching) {\n        var text = loggedIn ? 'There are no chat!' : __jsx(React.Fragment, null, \"There are no chat, please\", __jsx(Link, {\n          href: \"/auth/register\"\n        }, __jsx(\"a\", null, \" register \")), \"or\", __jsx(Link, {\n          href: \"/auth/login\"\n        }, __jsx(\"a\", null, \" login \")), \"to send message!\");\n        return __jsx(Message, {\n          data: {\n            isSystem: true,\n            text: text\n          }\n        });\n      }\n\n      var tempMessages = [];\n\n      while (i < messageCount) {\n        var previous = messages[i - 1];\n        var current = messages[i];\n        var next = messages[i + 1];\n        var userId = currentUser && currentUser._id ? currentUser._id : currentPerformer && currentPerformer._id ? currentPerformer._id : null;\n        var isMine = current.senderId === userId;\n        var currentMoment = moment(current.createdAt);\n        var prevBySameAuthor = false;\n        var nextBySameAuthor = false;\n        var startsSequence = true;\n        var endsSequence = true;\n        var showTimestamp = true;\n        var isOwner = conversation && conversation.performerId === current.senderId;\n        var canDelete = !current.isDeleted && currentPerformer && currentPerformer._id === conversation.performerId || !current.isDeleted && currentUser._id === current.senderId || !current.isDeleted && currentUser.roles && currentUser.roles.includes('admin');\n\n        if (previous) {\n          var previousMoment = moment(previous.createdAt);\n          var previousDuration = moment.duration(currentMoment.diff(previousMoment));\n          prevBySameAuthor = previous.senderId === current.senderId;\n\n          if (prevBySameAuthor && previousDuration.as('hours') < 1) {\n            startsSequence = false;\n          }\n\n          if (previousDuration.as('hours') < 1) {\n            showTimestamp = false;\n          }\n        }\n\n        if (next) {\n          var nextMoment = moment(next.createdAt);\n          var nextDuration = moment.duration(nextMoment.diff(currentMoment));\n          nextBySameAuthor = next.senderId === current.senderId;\n\n          if (nextBySameAuthor && nextDuration.as('hours') < 1) {\n            endsSequence = false;\n          }\n        }\n\n        if (current._id) {\n          tempMessages.push(__jsx(Message, {\n            onDelete: _this.onDelete.bind(_assertThisInitialized(_this), current._id),\n            canDelete: canDelete,\n            isOwner: isOwner,\n            key: i,\n            isMine: isMine,\n            startsSequence: startsSequence,\n            endsSequence: endsSequence,\n            showTimestamp: showTimestamp,\n            data: current\n          }));\n        } // Proceed to the next message.\n\n\n        i += 1;\n      }\n\n      _this.scrollToBottom();\n\n      return tempMessages;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"rejoin\", function () {\n      var conversation = _this.props.conversation;\n\n      if (conversation && conversation._id) {\n        var socket = _this.context;\n        conversation.type === 'stream_public' && socket.emit('public-stream/rejoin', {\n          conversationId: conversation._id\n        });\n        (conversation.type === 'stream_group' || conversation.type === 'stream_private') && socket.emit('REJOIN_ROOM', {\n          conversationId: conversation._id\n        });\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(MessageList, [{\n    key: \"componentDidMount\",\n    value: function () {\n      var _componentDidMount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        var conversation, socket;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.messagesRef) this.messagesRef = /*#__PURE__*/createRef();\n                conversation = this.props.conversation;\n                socket = this.context;\n\n                if (conversation && conversation._id) {\n                  socket && socket.on && socket.on(\"message_created_conversation_\".concat(conversation._id), function (data) {\n                    _this2.onMessage(data, 'created');\n                  });\n                  socket && socket.on && socket.on(\"message_deleted_conversation_\".concat(conversation._id), function (data) {\n                    _this2.onMessage(data, 'deleted');\n                  });\n                }\n\n                Router.events.on('routeChangeStart', this.onbeforeunload);\n                window.addEventListener('beforeunload', this.onbeforeunload);\n                this.reconnect();\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function componentDidMount() {\n        return _componentDidMount.apply(this, arguments);\n      }\n\n      return componentDidMount;\n    }()\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var conversation = this.props.conversation;\n      var socket = this.context;\n      socket && socket.off(\"message_created_conversation_\".concat(conversation._id));\n      socket && socket.off(\"message_deleted_conversation_\".concat(conversation._id));\n      socket && socket.off('reconnect', this.rejoin);\n      Router.events.on('routeChangeStart', this.onbeforeunload);\n      window.addEventListener('beforeunload', this.onbeforeunload);\n    }\n  }, {\n    key: \"handleScroll\",\n    value: function () {\n      var _handleScroll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(conversation, event) {\n        var _this$props4, message, isPublic, dispatchLoadMoreStreamMessages, page, fetching, items, total, canloadmore, ele;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _this$props4 = this.props, message = _this$props4.message, isPublic = _this$props4.isPublic, dispatchLoadMoreStreamMessages = _this$props4.loadMoreStreamMessages;\n                page = this.state.page;\n                fetching = message.fetching, items = message.items, total = message.total;\n                canloadmore = total > items.length;\n                ele = event.target;\n\n                if (canloadmore) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 7:\n                if (!(ele.scrollTop === 0 && conversation._id && !fetching && canloadmore)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                _context2.next = 10;\n                return this.setState({\n                  page: page + 1,\n                  onloadmore: true\n                });\n\n              case 10:\n                dispatchLoadMoreStreamMessages({\n                  conversationId: conversation._id,\n                  type: conversation.type,\n                  limit: 25,\n                  offset: page * 25,\n                  isPublic: isPublic\n                });\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function handleScroll(_x, _x2) {\n        return _handleScroll.apply(this, arguments);\n      }\n\n      return handleScroll;\n    }()\n  }, {\n    key: \"scrollToBottom\",\n    value: function scrollToBottom() {\n      var onloadmore = this.state.onloadmore;\n\n      if (onloadmore) {\n        return;\n      }\n\n      if (this.messagesRef && this.messagesRef.current) {\n        var ele = this.messagesRef.current;\n        window.setTimeout(function () {\n          ele.scroll({\n            top: ele.scrollHeight,\n            behavior: 'smooth'\n          });\n        }, 200);\n      }\n    }\n  }, {\n    key: \"reconnect\",\n    value: function reconnect() {\n      var socket = this.context;\n\n      if (socket) {\n        socket.on('reconnect', this.rejoin);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props5 = this.props,\n          conversation = _this$props5.conversation,\n          isPublic = _this$props5.isPublic,\n          message = _this$props5.message;\n      var fetching = message.fetching;\n      if (!this.messagesRef) this.messagesRef = /*#__PURE__*/createRef();\n      return __jsx(\"div\", {\n        className: \"message-list\",\n        onScroll: this.handleScroll.bind(this, conversation)\n      }, conversation && conversation._id && __jsx(React.Fragment, null, __jsx(\"div\", {\n        className: \"message-list-container\",\n        ref: this.messagesRef\n      }, fetching && __jsx(\"p\", {\n        className: \"text-center\"\n      }, \"fetching...\"), this.renderMessages()), __jsx(Compose, {\n        conversation: conversation,\n        isPublic: isPublic\n      })));\n    }\n  }]);\n\n  return MessageList;\n}(PureComponent);\n\nMessageList.contextType = SocketContext;\n\nvar mapStates = function mapStates(state) {\n  var _state$streamMessage = state.streamMessage,\n      conversationMap = _state$streamMessage.conversationMap,\n      activeConversation = _state$streamMessage.activeConversation;\n  var messages = activeConversation.data && conversationMap[activeConversation.data._id] ? conversationMap[activeConversation.data._id].items || [] : [];\n  var totalMessages = activeConversation.data && conversationMap[activeConversation.data._id] ? conversationMap[activeConversation.data._id].total || 0 : 0;\n  var fetching = activeConversation.data && conversationMap[activeConversation.data._id] ? conversationMap[activeConversation.data._id].fetching || false : false;\n  return {\n    message: {\n      items: messages,\n      total: totalMessages,\n      fetching: fetching\n    },\n    conversation: activeConversation.data,\n    currentUser: state.user.current,\n    currentPerformer: state.performer.current,\n    loggedIn: state.auth.loggedIn\n  };\n};\n\nvar mapDispatch = {\n  loadMoreStreamMessages: loadMoreStreamMessages,\n  receiveStreamMessageSuccess: receiveStreamMessageSuccess,\n  deleteMessage: deleteMessage,\n  deleteMessageSuccess: deleteMessageSuccess,\n  resetStreamMessage: resetStreamMessage\n};\nexport default connect(mapStates, mapDispatch)(MessageList);","map":{"version":3,"sources":["E:/WorkStation/Moldova/DTEST/src/components/stream-chat/MessageList.tsx"],"names":["React","PureComponent","createRef","connect","moment","Link","loadMoreStreamMessages","receiveStreamMessageSuccess","resetStreamMessage","deleteMessage","deleteMessageSuccess","SocketContext","Router","Compose","Message","MessageList","page","onloadmore","props","conversation","dispatchResetStreamMessage","_id","message","type","dispatchReceiveStreamMessageSuccess","dispatchDeleteMessageSuccess","messageId","dispatchDeleteMessage","currentUser","currentPerformer","loggedIn","messages","items","fetching","i","messageCount","length","text","isSystem","tempMessages","previous","current","next","userId","isMine","senderId","currentMoment","createdAt","prevBySameAuthor","nextBySameAuthor","startsSequence","endsSequence","showTimestamp","isOwner","performerId","canDelete","isDeleted","roles","includes","previousMoment","previousDuration","duration","diff","as","nextMoment","nextDuration","push","onDelete","bind","scrollToBottom","socket","context","emit","conversationId","messagesRef","on","data","onMessage","events","onbeforeunload","window","addEventListener","reconnect","off","rejoin","event","isPublic","dispatchLoadMoreStreamMessages","state","total","canloadmore","ele","target","scrollTop","setState","limit","offset","setTimeout","scroll","top","scrollHeight","behavior","handleScroll","renderMessages","contextType","mapStates","streamMessage","conversationMap","activeConversation","totalMessages","user","performer","auth","mapDispatch"],"mappings":"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","sourcesContent":["/* eslint-disable no-nested-ternary */\nimport React, { PureComponent, createRef } from 'react';\nimport { connect } from 'react-redux';\nimport moment from 'moment';\nimport Link from 'next/link';\nimport './MessageList.less';\nimport {\n  loadMoreStreamMessages,\n  receiveStreamMessageSuccess,\n  resetStreamMessage,\n  deleteMessage,\n  deleteMessageSuccess\n} from '@redux/stream-chat/actions';\nimport { SocketContext } from 'src/socket';\nimport { IUser, IPerformer } from 'src/interfaces';\nimport Router from 'next/router';\nimport Compose from './Compose';\nimport Message from './Message';\n\ninterface IProps {\n  loadMoreStreamMessages: Function;\n  receiveStreamMessageSuccess: Function;\n  message: any;\n  conversation: any;\n  currentUser: IUser;\n  currentPerformer: IPerformer;\n  isPublic?: boolean;\n  deleteMessage: Function;\n  deleteMessageSuccess: Function;\n  resetStreamMessage: Function;\n  loggedIn: boolean;\n}\nclass MessageList extends PureComponent<IProps> {\n  messagesRef: any;\n\n  state = {\n    page: 1,\n    onloadmore: false\n  };\n\n  async componentDidMount() {\n    if (!this.messagesRef) this.messagesRef = createRef();\n    const { conversation } = this.props;\n    const socket = this.context;\n    if (conversation && conversation._id) {\n      socket\n        && socket.on\n        && socket.on(\n          `message_created_conversation_${conversation._id}`,\n          (data) => {\n            this.onMessage(data, 'created');\n          }\n        );\n      socket\n        && socket.on\n        && socket.on(\n          `message_deleted_conversation_${conversation._id}`,\n          (data) => {\n            this.onMessage(data, 'deleted');\n          }\n        );\n    }\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n    window.addEventListener('beforeunload', this.onbeforeunload);\n    this.reconnect();\n  }\n\n  componentWillUnmount() {\n    const { conversation } = this.props;\n    const socket = this.context;\n    socket && socket.off(`message_created_conversation_${conversation._id}`);\n    socket && socket.off(`message_deleted_conversation_${conversation._id}`);\n    socket && socket.off('reconnect', this.rejoin);\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n    window.addEventListener('beforeunload', this.onbeforeunload);\n  }\n\n  async handleScroll(conversation, event) {\n    const {\n      message,\n      isPublic,\n      loadMoreStreamMessages: dispatchLoadMoreStreamMessages\n    } = this.props;\n    const { page } = this.state;\n    const { fetching, items, total } = message;\n    const canloadmore = total > items.length;\n    const ele = event.target;\n    if (!canloadmore) return;\n    if (ele.scrollTop === 0 && conversation._id && !fetching && canloadmore) {\n      await this.setState({ page: page + 1, onloadmore: true });\n      dispatchLoadMoreStreamMessages({\n        conversationId: conversation._id,\n        type: conversation.type,\n        limit: 25,\n        offset: page * 25,\n        isPublic\n      });\n    }\n  }\n\n  onbeforeunload = () => {\n    const { conversation, resetStreamMessage: dispatchResetStreamMessage } = this.props;\n    if (conversation && conversation._id) {\n      dispatchResetStreamMessage();\n    }\n  }\n\n  onMessage = (message, type) => {\n    const {\n      receiveStreamMessageSuccess: dispatchReceiveStreamMessageSuccess,\n      deleteMessageSuccess: dispatchDeleteMessageSuccess\n    } = this.props;\n    if (!message) {\n      return;\n    }\n    type === 'created' && dispatchReceiveStreamMessageSuccess(message);\n    type === 'deleted' && dispatchDeleteMessageSuccess(message);\n  };\n\n  onDelete = (messageId) => {\n    const { deleteMessage: dispatchDeleteMessage } = this.props;\n    if (!messageId) return;\n    dispatchDeleteMessage({ messageId });\n  };\n\n  renderMessages = () => {\n    const {\n      message,\n      currentUser,\n      currentPerformer,\n      conversation,\n      loggedIn\n    } = this.props;\n    const messages = message.items;\n    const { fetching } = message;\n    let i = 0;\n    const messageCount = messages && messages.length;\n    if (!messages.length && !fetching) {\n      const text = loggedIn ? (\n        'There are no chat!'\n      ) : (\n        <>\n          There are no chat, please\n          <Link href=\"/auth/register\">\n            <a> register </a>\n          </Link>\n          or\n          <Link href=\"/auth/login\">\n            <a> login </a>\n          </Link>\n          to send message!\n        </>\n      );\n      return <Message data={{ isSystem: true, text }} />;\n    }\n\n    const tempMessages = [];\n    while (i < messageCount) {\n      const previous = messages[i - 1];\n      const current = messages[i];\n      const next = messages[i + 1];\n      const userId = currentUser && currentUser._id\n        ? currentUser._id\n        : currentPerformer && currentPerformer._id\n          ? currentPerformer._id\n          : null;\n      const isMine = current.senderId === userId;\n      const currentMoment = moment(current.createdAt);\n      let prevBySameAuthor = false;\n      let nextBySameAuthor = false;\n      let startsSequence = true;\n      let endsSequence = true;\n      let showTimestamp = true;\n      const isOwner = conversation && conversation.performerId === current.senderId;\n      const canDelete = (!current.isDeleted\n          && currentPerformer\n          && currentPerformer._id === conversation.performerId)\n        || (!current.isDeleted && currentUser._id === current.senderId)\n        || (!current.isDeleted\n          && currentUser.roles\n          && currentUser.roles.includes('admin'));\n      if (previous) {\n        const previousMoment = moment(previous.createdAt);\n        const previousDuration = moment.duration(\n          currentMoment.diff(previousMoment)\n        );\n        prevBySameAuthor = previous.senderId === current.senderId;\n\n        if (prevBySameAuthor && previousDuration.as('hours') < 1) {\n          startsSequence = false;\n        }\n\n        if (previousDuration.as('hours') < 1) {\n          showTimestamp = false;\n        }\n      }\n\n      if (next) {\n        const nextMoment = moment(next.createdAt);\n        const nextDuration = moment.duration(nextMoment.diff(currentMoment));\n        nextBySameAuthor = next.senderId === current.senderId;\n\n        if (nextBySameAuthor && nextDuration.as('hours') < 1) {\n          endsSequence = false;\n        }\n      }\n      if (current._id) {\n        tempMessages.push(\n          <Message\n            onDelete={this.onDelete.bind(this, current._id)}\n            canDelete={canDelete}\n            isOwner={isOwner}\n            key={i}\n            isMine={isMine}\n            startsSequence={startsSequence}\n            endsSequence={endsSequence}\n            showTimestamp={showTimestamp}\n            data={current}\n          />\n        );\n      }\n      // Proceed to the next message.\n      i += 1;\n    }\n    this.scrollToBottom();\n    return tempMessages;\n  };\n\n  rejoin = () => {\n    const { conversation } = this.props;\n    if (conversation && conversation._id) {\n      const socket = this.context;\n      conversation.type === 'stream_public'\n        && socket.emit('public-stream/rejoin', {\n          conversationId: conversation._id\n        });\n      (conversation.type === 'stream_group'\n        || conversation.type === 'stream_private')\n        && socket.emit('REJOIN_ROOM', {\n          conversationId: conversation._id\n        });\n    }\n  };\n\n  scrollToBottom() {\n    const { onloadmore } = this.state;\n    if (onloadmore) {\n      return;\n    }\n    if (this.messagesRef && this.messagesRef.current) {\n      const ele: HTMLDivElement = this.messagesRef.current;\n      window.setTimeout(() => {\n        ele.scroll({\n          top: ele.scrollHeight,\n          behavior: 'smooth'\n        });\n      }, 200);\n    }\n  }\n\n  reconnect() {\n    const socket = this.context;\n    if (socket) {\n      socket.on('reconnect', this.rejoin);\n    }\n  }\n\n  render() {\n    const { conversation, isPublic, message } = this.props;\n    const { fetching } = message;\n    if (!this.messagesRef) this.messagesRef = createRef();\n    return (\n      <div\n        className=\"message-list\"\n        onScroll={this.handleScroll.bind(this, conversation)}\n      >\n        {conversation && conversation._id && (\n          <>\n            <div className=\"message-list-container\" ref={this.messagesRef}>\n              {fetching && <p className=\"text-center\">fetching...</p>}\n              {this.renderMessages()}\n            </div>\n            <Compose conversation={conversation} isPublic={isPublic} />\n          </>\n        )}\n      </div>\n    );\n  }\n}\n\nMessageList.contextType = SocketContext;\n\nconst mapStates = (state: any) => {\n  const { conversationMap, activeConversation } = state.streamMessage;\n  const messages = activeConversation.data && conversationMap[activeConversation.data._id]\n    ? conversationMap[activeConversation.data._id].items || []\n    : [];\n  const totalMessages = activeConversation.data && conversationMap[activeConversation.data._id]\n    ? conversationMap[activeConversation.data._id].total || 0\n    : 0;\n  const fetching = activeConversation.data && conversationMap[activeConversation.data._id]\n    ? conversationMap[activeConversation.data._id].fetching || false\n    : false;\n\n  return {\n    message: {\n      items: messages,\n      total: totalMessages,\n      fetching\n    },\n    conversation: activeConversation.data,\n    currentUser: state.user.current,\n    currentPerformer: state.performer.current,\n    loggedIn: state.auth.loggedIn\n  };\n};\n\nconst mapDispatch = {\n  loadMoreStreamMessages,\n  receiveStreamMessageSuccess,\n  deleteMessage,\n  deleteMessageSuccess,\n  resetStreamMessage\n};\n\nexport default connect(mapStates, mapDispatch)(MessageList);\n"]},"metadata":{},"sourceType":"module"}