{"ast":null,"code":"import { flatten } from 'lodash';\nimport { put, select } from 'redux-saga/effects';\nimport { createSagas } from '@lib/redux';\nimport { messageService } from '@services/message.service';\nimport { message } from 'antd';\nimport { getConversations, getConversationsSuccess, getConversationsFail, setActiveConversation, setActiveConversationSuccess, loadMessages, fetchingMessage, loadMessagesSuccess, sendMessage, sendMessageFail, sendMessageSuccess, getConversationDetail, getConversationDetailSuccess, readMessages, loadMoreMessages, loadMoreMessagesSuccess, searchConversations, searchConversationsFail, searchConversationsSuccess, updateLastMessage, loadMoreMessagesFail, loadMessagesFail, setActiveConversationFail } from './actions';\nconst conversationSagas = [{\n  on: getConversations,\n\n  *worker(data) {\n    try {\n      const resp = yield messageService.getConversations(data.payload);\n      yield put(getConversationsSuccess(resp.data));\n    } catch (e) {\n      // TODO - alert error\n      const error = yield Promise.resolve(e);\n      yield put(getConversationsFail(error));\n    }\n  }\n\n}, {\n  on: searchConversations,\n\n  *worker(data) {\n    try {\n      const resp = yield messageService.getConversations(data.payload);\n      yield put(searchConversationsSuccess(resp.data));\n    } catch (e) {\n      // TODO - alert error\n      const error = yield Promise.resolve(e);\n      yield put(searchConversationsFail(error));\n    }\n  }\n\n}, {\n  on: setActiveConversation,\n\n  *worker(data) {\n    try {\n      const {\n        source,\n        sourceId,\n        conversationId,\n        recipientId\n      } = data.payload;\n      const conversationMapping = yield select(state => state.conversation.mapping);\n\n      if (conversationId) {\n        // todo - check me later\n        if (conversationMapping[conversationId]) {\n          yield put(setActiveConversationSuccess(conversationMapping[conversationId]));\n          const readAllMessages = yield messageService.readAllInConversation(conversationId, recipientId);\n\n          if (readAllMessages) {\n            yield put(readMessages(conversationId));\n          }\n\n          yield put(loadMessages({\n            conversationId,\n            limit: 25,\n            offset: 0\n          }));\n        } else {// TODO - check me later, query to DB and update here\n        }\n      } else {\n        const resp = yield messageService.createConversation({\n          source,\n          sourceId\n        });\n        const conversation = resp.data;\n\n        if (conversationMapping[conversation._id]) {\n          yield put(setActiveConversationSuccess(conversationMapping[conversation._id]));\n        } else {\n          yield put(setActiveConversationSuccess(conversation));\n        }\n\n        yield put(loadMessages({\n          conversationId: conversation._id,\n          limit: 25,\n          offset: 0\n        }));\n      }\n    } catch (e) {\n      message.error('Error occured, please try again later');\n      yield put(setActiveConversationFail(e));\n    }\n  }\n\n}, {\n  on: getConversationDetail,\n\n  *worker(data) {\n    try {\n      const conversation = yield messageService.getConversationDetail(data.payload.id);\n      yield put(getConversationDetailSuccess(conversation.data));\n    } catch (e) {\n      yield put(getConversationsFail(e));\n    }\n  }\n\n}];\nconst messageSagas = [{\n  on: loadMessages,\n\n  *worker(data) {\n    try {\n      const messageMap = select(state => state.message.mapping);\n      const {\n        conversationId,\n        offset,\n        limit\n      } = data.payload;\n\n      if (messageMap[conversationId] && messageMap[conversationId].fetching) {\n        // do nothing if it is fetching\n        return;\n      }\n\n      yield put(fetchingMessage({\n        conversationId\n      }));\n      const resp = yield messageService.getMessages(conversationId, {\n        offset,\n        limit\n      });\n      yield put(loadMessagesSuccess({\n        conversationId,\n        items: resp.data.data,\n        total: resp.data.total\n      }));\n    } catch (e) {\n      message.error('Error occured, please try again later');\n      yield put(loadMessagesFail(e));\n    }\n  }\n\n}, {\n  on: loadMoreMessages,\n\n  *worker(data) {\n    try {\n      const messageMap = select(state => state.message.mapping);\n      const {\n        conversationId,\n        offset,\n        limit\n      } = data.payload;\n\n      if (messageMap[conversationId] && messageMap[conversationId].fetching) {\n        // do nothing if it is fetching\n        return;\n      }\n\n      yield put(fetchingMessage({\n        conversationId\n      }));\n      const resp = yield messageService.getMessages(conversationId, {\n        offset,\n        limit\n      });\n      yield put(loadMoreMessagesSuccess({\n        conversationId,\n        items: resp.data.data,\n        total: resp.data.total\n      }));\n    } catch (e) {\n      message.error('Error occured, please try again later');\n      yield put(loadMoreMessagesFail(e));\n    }\n  }\n\n}, {\n  on: sendMessage,\n\n  *worker(req) {\n    try {\n      const {\n        conversationId,\n        data\n      } = req.payload;\n      const resp = yield messageService.sendMessage(conversationId, data);\n      yield put(sendMessageSuccess(resp.data));\n      yield put(updateLastMessage({\n        conversationId,\n        lastMessage: data.text\n      }));\n    } catch (e) {\n      yield put(sendMessageFail(e));\n    }\n  }\n\n}];\nexport default flatten([createSagas(conversationSagas), createSagas(messageSagas)]);","map":null,"metadata":{},"sourceType":"module"}